/home/flomik/StudioProjects/Tempo/lib/main.dart main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/database_providers.dart';
import 'package:tempo/src/data/database/database_seeder.dart';
import 'package:tempo/src/presentation/core/theme/theme_provider.dart';

import 'package:flutter/cupertino.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'src/core/gen/l10n/app_localizations.dart';
import 'src/core/logger/riverpod_log.dart';
// import 'src/presentation/core/theme/theme.dart'; // Theme extensions removed/unused
import 'src/presentation/core/widgets/ios_main_layout.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(ProviderScope(observers: [RiverpodObserver()], child: const MyApp()));
}

class MyApp extends ConsumerStatefulWidget {
  const MyApp({super.key});

  @override
  ConsumerState<MyApp> createState() => _MyAppState();
}

class _MyAppState extends ConsumerState<MyApp> {
  @override
  void initState() {
    super.initState();
    _initializeDatabase();
  }

  Future<void> _initializeDatabase() async {
    // Инициализация БД и seed данных
    final db = ref.read(appDatabaseProvider);
    final seeder = DatabaseSeeder(db);
    await seeder.seedIfEmpty();
  }

  @override
  Widget build(BuildContext context) {
    final themeMode = ref.watch(themeProvider);
    
    return MediaQuery.withClampedTextScaling(
      maxScaleFactor: 1.5,
      child: CupertinoApp(
        title: 'Tempo',
        // onGenerateTitle: (context) => AppLocalizations.of(context).appTitle,
        localizationsDelegates: const [
          AppLocalizations.delegate,
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        supportedLocales: AppLocalizations.supportedLocales,
        theme: CupertinoThemeData(
          brightness: themeMode == AppThemeMode.dark ? Brightness.dark : Brightness.light,
          primaryColor: const Color(0xFF007AFF),
          scaffoldBackgroundColor: themeMode == AppThemeMode.dark 
              ? const Color(0xFF000000) 
              : const Color(0xFFF2F2F7),
          barBackgroundColor: themeMode == AppThemeMode.dark
              ? const Color(0xFF1C1C1E)
              : const Color(0xF0F9F9F9),
        ),
        home: const IosMainLayout(),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/complete_task_use_case.dart complete_task_use_case.dart
import 'package:tempo/src/domain/repositories/task_repository.dart';

/// Use case для отметки задачи как выполненной
class CompleteTaskUseCase {
  final TaskRepository _repository;

  CompleteTaskUseCase(this._repository);

  /// Отметить задачу выполненной
  /// Автоматически создается следующий экземпляр для повторяющихся задач
  Future<void> call(String taskId) async {
    await _repository.completeTask(taskId);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/create_activity_type_use_case.dart create_activity_type_use_case.dart
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';

class CreateActivityTypeUseCase {
  final ActivityTypeRepository _repository;

  CreateActivityTypeUseCase(this._repository);

  Future<void> call(String name, String color) async {
    // Generate ID? Repository might handle it or we do it here. 
    // Drift ID is usually int autoincrement unless defined as String.
    // In db code it was text id.
    // Let's generate uuid? Or let repo handle if it takes entity.
    // Repo takes ActivityType.
    // I need uuid generator.
    final id = DateTime.now().millisecondsSinceEpoch.toString(); // Simple ID for now
    await _repository.createActivityType(
      name: name,
      color: color,
      order: 0, // Default order
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/router_use_case.dart router_use_case.dart
import '../repositories/router_repository.dart';

final class GetOnboardingStatusUseCase {
  GetOnboardingStatusUseCase(this.repository);

  final RouterRepository repository;

  bool call() {
    return repository.isOnboardingCompleted();
  }
}

final class GetUserLoginStatusUseCase {
  GetUserLoginStatusUseCase(this.repository);

  final RouterRepository repository;

  bool call() {
    return repository.isUserLoggedIn();
  }
}

final class MarkOnboardingCompletedUseCase {
  MarkOnboardingCompletedUseCase(this.repository);

  final RouterRepository repository;

  void call() {
    repository.saveOnboardingAsCompleted();
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/detect_long_session_use_case.dart detect_long_session_use_case.dart
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/repositories/session_repository.dart';

/// Use case для детекции "забытых" длинных сессий
class DetectLongSessionUseCase {
  final SessionRepository _repository;
  
  /// Порог в часах для уведомления
  final int thresholdHours;

  DetectLongSessionUseCase(
    this._repository, {
    this.thresholdHours = 8,
  });

  /// Проверить активную сессию на длительность
  /// Возвращает активную сессию если она превышает порог, иначе null
  Future<Session?> call() async {
    final activeSession = await _repository.watchActiveSession().first;
    
    if (activeSession == null) {
      return null;
    }

    final duration = DateTime.now().difference(activeSession.startAt);
    
    if (duration.inHours >= thresholdHours) {
      return activeSession;
    }

    return null;
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/reorder_activity_types_use_case.dart reorder_activity_types_use_case.dart
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';

class ReorderActivityTypesUseCase {
  final ActivityTypeRepository _repository;

  ReorderActivityTypesUseCase(this._repository);

  Future<void> call(List<String> orderedIds) async {
    await _repository.reorderActivityTypes(orderedIds);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/authentication_use_case.dart authentication_use_case.dart
import '../../core/base/result.dart';
import '../entities/login_entity.dart';
import '../entities/sign_up_entity.dart';
import '../repositories/authentication_repository.dart';

final class RegisterUseCase {
  RegisterUseCase(this.repository);

  final AuthenticationRepository repository;

  Future<SignUpResponseEntity> call(SignUpRequestEntity request) async {
    return repository.register(request);
  }
}

final class LoginUseCase {
  LoginUseCase(this.repository);

  final AuthenticationRepository repository;

  Future<Result<LoginResponseEntity, String>> call({
    required String email,
    required String password,
    bool? shouldRemember,
  }) async {
    final request = LoginRequestEntity(
      username: email,
      password: password,
      shouldRemeber: shouldRemember,
    );

    final result = await repository.login(request);

    return switch (result) {
      Success(:final data) => Success(data: data),
      Error(:final error) => Error(error.message),
      _ => const Error('Something went wrong'),
    };
  }
}

final class LogoutUseCase {
  LogoutUseCase(this.repository);

  final AuthenticationRepository repository;

  Future<void> call() async {
    return repository.logout();
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/locale_use_case.dart locale_use_case.dart
import '../repositories/locale_repository.dart';

class GetCurrentLocaleUseCase {
  GetCurrentLocaleUseCase(this.repository);

  final LocaleRepository repository;

  Future<String> call() async {
    return repository.getLanguage();
  }
}

class SetCurrentLocaleUseCase {
  SetCurrentLocaleUseCase(this.repository);

  final LocaleRepository repository;

  Future<void> call(String language) async {
    return repository.setLanguage(language);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/add_manual_session_use_case.dart add_manual_session_use_case.dart
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/entities/conflict_resolution.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';
import 'package:tempo/src/domain/repositories/session_repository.dart';

/// Результат добавления сессии вручную
sealed class AddManualSessionResult {
  bool get isSuccess => this is AddManualSessionSuccess;
  List<SessionConflict> get conflicts => 
      this is AddManualSessionConflict 
          ? (this as AddManualSessionConflict).conflicts 
          : [];
}

/// Успешно добавлено
class AddManualSessionSuccess extends AddManualSessionResult {}

/// Обнаружены конфликты - требуется разрешение
class AddManualSessionConflict extends AddManualSessionResult {
  final List<SessionConflict> conflicts;

  AddManualSessionConflict(this.conflicts);
}

/// Use case для добавления сессии вручную с проверкой конфликтов
class AddManualSessionUseCase {
  final SessionRepository _sessionRepository;
  final ActivityTypeRepository _activityTypeRepository;

  AddManualSessionUseCase(
    this._sessionRepository,
    this._activityTypeRepository,
  );

  /// Добавить сессию вручную
  /// Возвращает Success или Conflict если есть пересечения
  Future<AddManualSessionResult> call({
    required String activityTypeId,
    required DateTime startAt,
    required DateTime endAt,
    String? note,
  }) async {
    // Получить имя активности для отображения в конфликтах
    final activityTypes = await _activityTypeRepository.watchActivityTypes().first;
    final activityType = activityTypes.firstWhere((a) => a.id == activityTypeId);

    // Проверить конфликты
    final conflicts = await _sessionRepository.detectConflicts(
      candidateStart: startAt,
      candidateEnd: endAt,
      candidateActivityName: activityType.name,
    );

    if (conflicts.isNotEmpty) {
      return AddManualSessionConflict(conflicts);
    }

    // Нет конфликтов - создать сессию
    await _sessionRepository.createSession(
      activityTypeId: activityTypeId,
      startAt: startAt,
      endAt: endAt,
      note: note,
    );

    return AddManualSessionSuccess();
  }

  /// Разрешить конфликт и создать сессию
  Future<void> resolveAndCreate({
    required SessionConflict conflict,
    required ConflictResolutionStrategy strategy,
    required String activityTypeId,
    required DateTime startAt,
    required DateTime endAt,
    String? note,
  }) async {
    await _sessionRepository.resolveConflict(
      conflict: conflict,
      strategy: strategy,
      newActivityTypeId: activityTypeId,
      newStartAt: startAt,
      newEndAt: endAt,
      note: note,
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/update_activity_type_use_case.dart update_activity_type_use_case.dart
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';

class UpdateActivityTypeUseCase {
  final ActivityTypeRepository _repository;

  UpdateActivityTypeUseCase(this._repository);

  Future<void> call(ActivityType activityType) async {
    await _repository.updateActivityType(activityType);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/start_session_use_case.dart start_session_use_case.dart
import 'package:tempo/src/domain/repositories/session_repository.dart';

/// Use case для запуска новой сессии активности
class StartSessionUseCase {
  final SessionRepository _repository;

  StartSessionUseCase(this._repository);

  /// Запустить новую сессию
  /// Автоматически закрывает активную сессию если есть
  Future<void> call(String activityTypeId) async {
    await _repository.startSession(activityTypeId);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/stop_session_use_case.dart stop_session_use_case.dart
import 'package:tempo/src/domain/repositories/session_repository.dart';

/// Use case для остановки активной сессии
class StopSessionUseCase {
  final SessionRepository _repository;

  StopSessionUseCase(this._repository);

  /// Остановить текущую активную сессию
  Future<void> call() async {
    await _repository.stopActiveSession();
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/create_task_use_case.dart create_task_use_case.dart
import 'package:tempo/src/domain/entities/repeat_rule.dart';
import 'package:tempo/src/domain/repositories/task_repository.dart';

/// Use case для создания новой задачи
class CreateTaskUseCase {
  final TaskRepository _repository;

  CreateTaskUseCase(this._repository);

  /// Создать новую задачу
  Future<void> call({
    required String title,
    DateTime? deadline,
    RepeatRule? repeatRule,
  }) async {
    await _repository.createTask(
      title: title,
      deadline: deadline,
      repeatRule: repeatRule,
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/reset_repository_use_case.dart reset_repository_use_case.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ResetRepositoryUseCase {
  const ResetRepositoryUseCase();

  /// Invalidates all repository dependencies in the dependency injection
  /// container.
  ///
  /// This method will invalidate all repository providers, forcing them to be
  /// recreated on next access. This is useful for clearing cached data and
  /// ensuring fresh repository instances.
  ///
  /// This is particularly important in scenarios where cached data needs to be
  /// cleared and fresh repository instances are required. For example, when
  /// switching between different businesses, or when a user logs out and then
  /// logs back in, we need to ensure that repositories do not retain data from
  /// the previous context. Without invalidation, repositories would retain
  /// data from the previous state since they are kept alive by the dependency
  /// injection container.
  void call(Ref ref) {
    // Invalidate all repository providers
    ref.container.getAllProviderElements().forEach((element) {
      if (element.provider.name!.contains('Repository')) {
        ref.invalidate(element.provider);
      }
    });
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/delete_activity_type_use_case.dart delete_activity_type_use_case.dart
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';

class DeleteActivityTypeUseCase {
  final ActivityTypeRepository _repository;

  DeleteActivityTypeUseCase(this._repository);

  Future<void> call(String id) async {
    await _repository.deleteActivityType(id);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/use_cases/switch_session_use_case.dart switch_session_use_case.dart
import 'package:tempo/src/domain/repositories/session_repository.dart';

/// Use case для переключения на другую активность
class SwitchSessionUseCase {
  final SessionRepository _repository;

  SwitchSessionUseCase(this._repository);

  /// Переключиться на другую активность
  /// Атомарно закрывает текущую и открывает новую
  Future<void> call(String newActivityTypeId) async {
    await _repository.switchSession(newActivityTypeId);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/entities/login_entity.dart login_entity.dart
interface class LoginEntity {}

class LoginRequestEntity extends LoginEntity {
  LoginRequestEntity({
    required this.username,
    required this.password,
    this.shouldRemeber = false,
  });

  final String username;
  final String password;
  final bool? shouldRemeber;
}

class LoginResponseEntity extends LoginEntity {
  LoginResponseEntity({required this.accessToken});

  final String accessToken;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/entities/sign_up_entity.dart sign_up_entity.dart
interface class SignUpEntity {}

class SignUpRequestEntity extends SignUpEntity {
  SignUpRequestEntity({
    required this.firstName,
    required this.lastName,
    required this.email,
    required this.password,
  });

  final String firstName;
  final String lastName;
  final String email;
  final String password;
}

class SignUpResponseEntity extends SignUpEntity {
  SignUpResponseEntity({required this.accessToken});

  final String accessToken;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/entities/conflict_resolution.dart conflict_resolution.dart
/// Стратегии разрешения конфликтов сессий
enum ConflictResolutionStrategy {
  /// Обрезать предыдущую сессию до начала новой 
  trimPrevious,
  
  /// Обрезать новую сессию до конца предыдущей
  trimNew,
  
  /// Разрезать предыдущую сессию вокруг новой
  /// (создать две части: до и после новой)
  splitPrevious,
  
  /// Отменить операцию
  cancel,
}

/// Описание конфликта между сессиями
class SessionConflict {
  /// ID существующей (конфликтующей) сессии
  final String existingSessionId;
  
  /// Название типа активности существующей сессии
  final String existingActivityName;
  
  /// Время начала существующей сессии
  final DateTime existingStart;
  
  /// Время окончания существующей сессии (null если активна)
  final DateTime? existingEnd;
  
  /// Время начала новой (кандидата) сессии
  final DateTime candidateStart;
  
  /// Время окончания новой сессии
  final DateTime candidateEnd;
  
  /// Название типа активности новой сессии
  final String candidateActivityName;

  const SessionConflict({
    required this.existingSessionId,
    required this.existingActivityName,
    required this.existingStart,
    this.existingEnd,
    required this.candidateStart,
    required this.candidateEnd,
    required this.candidateActivityName,
  });

  /// Вычислить продолжительность пересечения
  Duration get overlapDuration {
    final existingEndTime = existingEnd ?? candidateEnd;
    final overlapStart = existingStart.isAfter(candidateStart) 
        ? existingStart 
        : candidateStart;
    final overlapEnd = existingEndTime.isBefore(candidateEnd) 
        ? existingEndTime 
        : candidateEnd;
    
    return overlapEnd.difference(overlapStart);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/entities/repeat_rule.dart repeat_rule.dart
import 'dart:convert';

/// Базовый класс для правил повторения задач
sealed class RepeatRule {
  const RepeatRule();
  
  /// Сериализация в JSON string для хранения в БД
  String toJson();
  
  /// Десериализация из JSON string
  static RepeatRule fromJson(String json, int type) {
    final map = jsonDecode(json) as Map<String, dynamic>;
    
    return switch (type) {
      1 => FixedScheduleRepeat.fromMap(map),
      2 => XTimesInNDaysRepeat.fromMap(map),
      3 => EveryNDaysAfterCompletionRepeat.fromMap(map),
      _ => throw ArgumentError('Unknown repeat type: $type'),
    };
  }
}

/// Повторение по фиксированному расписанию (дни недели)
class FixedScheduleRepeat extends RepeatRule {
  /// Дни недели: 1=понедельник, 7=воскресенье
  final Set<int> weekdays;

  const FixedScheduleRepeat(this.weekdays);

  factory FixedScheduleRepeat.fromMap(Map<String, dynamic> map) {
    return FixedScheduleRepeat(
      (map['weekdays'] as List).cast<int>().toSet(),
    );
  }

  @override
  String toJson() {
    return jsonEncode({
      'weekdays': weekdays.toList(),
    });
  }

  /// Проверить, попадает ли дата на один из выбранных дней недели
  bool matchesDate(DateTime date) {
    return weekdays.contains(date.weekday);
  }
}

/// Повторение X раз за N дней (ключевой режим из ТЗ)
class XTimesInNDaysRepeat extends RepeatRule {
  /// Количество раз
  final int times;
  
  /// Количество дней
  final int days;

  const XTimesInNDaysRepeat({
    required this.times,
    required this.days,
  });

  factory XTimesInNDaysRepeat.fromMap(Map<String, dynamic> map) {
    return XTimesInNDaysRepeat(
      times: map['times'] as int,
      days: map['days'] as int,
    );
  }

  @override
  String toJson() {
    return jsonEncode({
      'times': times,
      'days': days,
    });
  }
}

/// Повторение каждые N дней после выполнения
class EveryNDaysAfterCompletionRepeat extends RepeatRule {
  /// Количество дней
  final int days;

  const EveryNDaysAfterCompletionRepeat(this.days);

  factory EveryNDaysAfterCompletionRepeat.fromMap(Map<String, dynamic> map) {
    return EveryNDaysAfterCompletionRepeat(map['days'] as int);
  }

  @override
  String toJson() {
    return jsonEncode({
      'days': days,
    });
  }

  /// Вычислить следующую дату по времени последнего выполнения
  DateTime nextOccurrence(DateTime completedAt) {
    return completedAt.add(Duration(days: days));
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/repositories/activity_type_repository.dart activity_type_repository.dart
import 'package:tempo/src/data/database/drift_database.dart';

/// Интерфейс репозитория для работы с типами активности
abstract class ActivityTypeRepository {
  /// Получить все типы активности (Stream для реактивности)
  Stream<List<ActivityType>> watchActivityTypes();
  
  /// Создать новый тип активности
  Future<void> createActivityType({
    required String name,
    required String color,
    required int order,
    bool isHidden = false,
  });
  
  /// Обновить существующий тип
  Future<void> updateActivityType(ActivityType activityType);
  
  /// Удалить тип активности
  Future<void> deleteActivityType(String id);
  
  /// Проверить, используется ли тип в сессиях
  Future<bool> isActivityTypeInUse(String id);
  
  /// Получить следующий порядковый номер для нового типа
  Future<int> getNextOrder();
  
  /// Переупорядочить типы активности
  Future<void> reorderActivityTypes(List<String> orderedIds);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/repositories/router_repository.dart router_repository.dart
abstract class RouterRepository {
  bool isOnboardingCompleted();

  bool isUserLoggedIn();

  void saveOnboardingAsCompleted();
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/repositories/session_repository.dart session_repository.dart
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/entities/conflict_resolution.dart';

/// Интерфейс репозитория для работы с сессиями активности
abstract class SessionRepository {
  /// Получить активную сессию (Stream для реактивности)
  Stream<Session?> watchActiveSession();
  
  /// Получить сессии за период
  Stream<List<SessionWithActivityType>> watchSessionsForPeriod({
    required DateTime from,
    required DateTime to,
  });
  
  /// Получить сессии за конкретный день
  Future<List<Session>> getSessionsForDay(DateTime day);
  
  /// Создать новую сессию
  Future<void> createSession({
    required String activityTypeId,
    required DateTime startAt,
    DateTime? endAt,
    String? note,
  });
  
  /// Обновить существующую сессию
  Future<void> updateSession(Session session);
  
  /// Удалить сессию
  Future<void> deleteSession(String id);
  
  /// Запустить новую сессию (закрыть текущую если есть)
  Future<void> startSession(String activityTypeId);
  
  /// Остановить активную сессию
  Future<void> stopActiveSession();
  
  /// Переключиться на другую активность (закрыть текущую, открыть новую)
  Future<void> switchSession(String newActivityTypeId);
  
  /// Детекция конфликтов с существующими сессиями
  Future<List<SessionConflict>> detectConflicts({
    required DateTime candidateStart,
    required DateTime candidateEnd,
    required String candidateActivityName,
    String? excludeSessionId,
  });
  
  /// Разрешить конфликт с выбранной стратегией
  Future<void> resolveConflict({
    required SessionConflict conflict,
    required ConflictResolutionStrategy strategy,
    required String newActivityTypeId,
    DateTime? newStartAt,
    DateTime? newEndAt,
    String? note,
  });
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/repositories/authentication_repository.dart authentication_repository.dart
import '../../core/base/failure.dart';
import '../../core/base/repository.dart';
import '../../core/base/result.dart';
import '../entities/login_entity.dart';
import '../entities/sign_up_entity.dart';

abstract base class AuthenticationRepository extends Repository {
  Future<SignUpResponseEntity> register(SignUpRequestEntity data);

  Future<Result<LoginResponseEntity, Failure>> login(LoginRequestEntity data);

  Future<bool> rememberMe({bool? rememberMe});

  Future<String> forgotPassword(Map<String, dynamic> data);

  Future<String> resetPassword(Map<String, dynamic> data);

  Future<String> verifyOTP(Map<String, dynamic> data);

  Future<String> resendOTP(Map<String, dynamic> data);

  Future<void> logout();
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/repositories/task_repository.dart task_repository.dart
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/entities/repeat_rule.dart';

/// Интерфейс репозитория для работы с задачами
abstract class TaskRepository {
  /// Получить задачи по статусу (Stream для реактивности)
  Stream<List<Task>> watchTasksByStatus(TaskStatus? status);
  
  /// Получить просроченные задачи
  Future<List<Task>> getOverdueTasks();
  
  /// Получить задачи на конкретную дату
  Future<List<Task>> getTasksForDate(DateTime date);
  
  /// Создать новую задачу
  Future<void> createTask({
    required String title,
    TaskStatus status = TaskStatus.active,
    DateTime? deadline,
    RepeatRule? repeatRule,
  });
  
  /// Обновить задачу
  Future<void> updateTask(Task task, {RepeatRule? repeatRule});
  
  /// Отметить задачу как выполненную
  /// Для повторяющихся - создается следующий экземпляр
  Future<void> completeTask(String taskId);
  
  /// Отложить задачу (snooze) до указанной даты
  Future<void> snoozeTask(String taskId, DateTime until);
  
  /// Перенести задачу на другую дату (изменить deadline)
  Future<void> rescheduleTask(String taskId, DateTime newDeadline);
  
  /// Удалить задачу
  Future<void> deleteTask(String taskId);
  
  /// Архивировать задачу
  Future<void> archiveTask(String taskId);
  
  /// Получить количество выполнений задачи за период (для XTimesInNDays)
  Future<int> getCompletionCount(String taskId, DateTime from, DateTime to);
  
  /// Получить правило повторения для задачи
  Future<RepeatRule?> getRepeatRule(String taskId);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/domain/repositories/locale_repository.dart locale_repository.dart
abstract class LocaleRepository {
  Future<void> setLanguage(String language);

  Future<String> getLanguage();
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/extensions/riverpod_extensions.dart riverpod_extensions.dart
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Works for sync providers only
/// Usage: ValueListenable myListenable = ref.asListenable(provider);
extension RefAsListenable on Ref {
  ValueListenable<T> asListenable<T>(ProviderBase<T> provider) {
    final valueNotifier = ValueNotifier(read(provider));

    final providerSubscription = listen<T>(provider, (_, next) {
      // Only update if the value has actually changed
      if (valueNotifier.value != next) {
        valueNotifier.value = next;
      }
    });

    onResume(() {
      final latestValue = read(provider);
      // Again, only update if there's a change
      if (valueNotifier.value != latestValue) {
        valueNotifier.value = latestValue;
      }
    });

    onDispose(() {
      providerSubscription.close();
      valueNotifier.dispose();
    });

    return valueNotifier;
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/extensions/app_localization.dart app_localization.dart
import 'package:flutter/material.dart';

import '../gen/l10n/app_localizations.dart';

extension AppLocalizationExtension on AppLocalizations {
  String getLanguageName(String languageCode) {
    return switch (languageCode) {
      'en' => english,
      'bn' => bangla,
      'ar' => arabic,
      _ => languageCode,
    };
  }
}

extension BuildContextLocalizationExtension on BuildContext {
  AppLocalizations get locale => AppLocalizations.of(this);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/extensions/validation.dart validation.dart
import 'package:flutter/material.dart';

import '../utiliity/validation/validation.dart';

extension ValidatorContextExtension on BuildContext {
  Validator get validator => Validator(this);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/extensions/go_router_extension.dart go_router_extension.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

extension GoRouterExtension on BuildContext {
  void pushNamedAndRemoveUntil(String routeName) {
    while (canPop()) {
      pop();
    }
    pushReplacementNamed(routeName);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/di/parts/repository_providers.g.dart repository_providers.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'repository_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$sessionRepositoryHash() => r'91112356804d92a94b2bb3a25316a7bfd9cee446';

/// Provider для SessionRepository
///
/// Copied from [sessionRepository].
@ProviderFor(sessionRepository)
final sessionRepositoryProvider =
    AutoDisposeProvider<SessionRepository>.internal(
      sessionRepository,
      name: r'sessionRepositoryProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$sessionRepositoryHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef SessionRepositoryRef = AutoDisposeProviderRef<SessionRepository>;
String _$activityTypeRepositoryHash() =>
    r'91949559c840d253516c8956e08e6a15d87088bf';

/// Provider для ActivityTypeRepository
///
/// Copied from [activityTypeRepository].
@ProviderFor(activityTypeRepository)
final activityTypeRepositoryProvider =
    AutoDisposeProvider<ActivityTypeRepository>.internal(
      activityTypeRepository,
      name: r'activityTypeRepositoryProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$activityTypeRepositoryHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef ActivityTypeRepositoryRef =
    AutoDisposeProviderRef<ActivityTypeRepository>;
String _$taskRepositoryHash() => r'8650427e0b948c2135c0f0e3f365a93126c9e66b';

/// Provider для TaskRepository
///
/// Copied from [taskRepository].
@ProviderFor(taskRepository)
final taskRepositoryProvider = AutoDisposeProvider<TaskRepository>.internal(
  taskRepository,
  name: r'taskRepositoryProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$taskRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef TaskRepositoryRef = AutoDisposeProviderRef<TaskRepository>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/di/parts/database_providers.g.dart database_providers.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$appDatabaseHash() => r'3db8efb59043d58a020432b725dc5c954aca9b63';

/// Provider для Drift database instance
///
/// Copied from [appDatabase].
@ProviderFor(appDatabase)
final appDatabaseProvider = AutoDisposeProvider<AppDatabase>.internal(
  appDatabase,
  name: r'appDatabaseProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$appDatabaseHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef AppDatabaseRef = AutoDisposeProviderRef<AppDatabase>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/di/parts/use_case_providers.dart use_case_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/repository_providers.dart';
import 'package:tempo/src/domain/use_cases/add_manual_session_use_case.dart';
import 'package:tempo/src/domain/use_cases/complete_task_use_case.dart';
import 'package:tempo/src/domain/use_cases/create_task_use_case.dart';
import 'package:tempo/src/domain/use_cases/detect_long_session_use_case.dart';
import 'package:tempo/src/domain/use_cases/create_activity_type_use_case.dart';
import 'package:tempo/src/domain/use_cases/delete_activity_type_use_case.dart';
import 'package:tempo/src/domain/use_cases/start_session_use_case.dart';
import 'package:tempo/src/domain/use_cases/stop_session_use_case.dart';
import 'package:tempo/src/domain/use_cases/switch_session_use_case.dart';
import 'package:tempo/src/domain/use_cases/update_activity_type_use_case.dart';
import 'package:tempo/src/domain/use_cases/reorder_activity_types_use_case.dart';

// ============================================================
// Session Use Cases
// ============================================================

final startSessionUseCaseProvider = Provider((ref) {
  return StartSessionUseCase(ref.watch(sessionRepositoryProvider));
});

final stopSessionUseCaseProvider = Provider((ref) {
  return StopSessionUseCase(ref.watch(sessionRepositoryProvider));
});

final switchSessionUseCaseProvider = Provider((ref) {
  return SwitchSessionUseCase(ref.watch(sessionRepositoryProvider));
});

final addManualSessionUseCaseProvider = Provider((ref) {
  return AddManualSessionUseCase(
    ref.watch(sessionRepositoryProvider),
    ref.watch(activityTypeRepositoryProvider),
  );
});

final detectLongSessionUseCaseProvider = Provider((ref) {
  return DetectLongSessionUseCase(ref.watch(sessionRepositoryProvider));
});

// ============================================================
// Task Use Cases
// ============================================================

final createTaskUseCaseProvider = Provider((ref) {
  return CreateTaskUseCase(ref.watch(taskRepositoryProvider));
});

final completeTaskUseCaseProvider = Provider((ref) {
  return CompleteTaskUseCase(ref.watch(taskRepositoryProvider));
});

// ============================================================
// Activity Type Use Cases
// ============================================================

final createActivityTypeUseCaseProvider = Provider((ref) {
  return CreateActivityTypeUseCase(ref.watch(activityTypeRepositoryProvider));
});

final updateActivityTypeUseCaseProvider = Provider((ref) {
  return UpdateActivityTypeUseCase(ref.watch(activityTypeRepositoryProvider));
});

final deleteActivityTypeUseCaseProvider = Provider((ref) {
  return DeleteActivityTypeUseCase(ref.watch(activityTypeRepositoryProvider));
});

final reorderActivityTypesUseCaseProvider = Provider((ref) {
  // Need to import usecase if I can, but imports are at top. I'll rely on auto-fix or just add import in next step if it fails?
  // I should add import first.
  // Wait, I can't add import easily without full file write or another replace call at top.
  // I will assume simple name resolution won't work without import.
  // I will use write_to_file to overwrite the whole file or ...
  // Let's replace the top imports block first.
  return ReorderActivityTypesUseCase(ref.watch(activityTypeRepositoryProvider));
});



================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/di/parts/database_providers.dart database_providers.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:tempo/src/data/database/drift_database.dart';

part 'database_providers.g.dart';

/// Provider для Drift database instance
@riverpod
AppDatabase appDatabase(AppDatabaseRef ref) {
  final db = AppDatabase();
  ref.onDispose(() => db.close());
  return db;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/di/parts/repository_providers.dart repository_providers.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:tempo/src/core/di/parts/database_providers.dart';
import 'package:tempo/src/data/repositories/activity_type_repository_impl.dart';
import 'package:tempo/src/data/repositories/session_repository_impl.dart';
import 'package:tempo/src/data/repositories/task_repository_impl.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';
import 'package:tempo/src/domain/repositories/session_repository.dart';
import 'package:tempo/src/domain/repositories/task_repository.dart';

part 'repository_providers.g.dart';

/// Provider для SessionRepository
@riverpod
SessionRepository sessionRepository(SessionRepositoryRef ref) {
  final db = ref.watch(appDatabaseProvider);
  return SessionRepositoryImpl(db);
}

/// Provider для ActivityTypeRepository
@riverpod
ActivityTypeRepository activityTypeRepository(ActivityTypeRepositoryRef ref) {
  final db = ref.watch(appDatabaseProvider);
  return ActivityTypeRepositoryImpl(db);
}

/// Provider для TaskRepository
@riverpod
TaskRepository taskRepository(TaskRepositoryRef ref) {
  final db = ref.watch(appDatabaseProvider);
  return TaskRepositoryImpl(db);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/base/exceptions.freezed.dart exceptions.freezed.dart
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$CustomException {

 String get message; StackTrace? get stackTrace;
/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CustomExceptionCopyWith<CustomException> get copyWith => _$CustomExceptionCopyWithImpl<CustomException>(this as CustomException, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CustomException&&(identical(other.message, message) || other.message == message)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,stackTrace);

@override
String toString() {
  return 'CustomException(message: $message, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $CustomExceptionCopyWith<$Res>  {
  factory $CustomExceptionCopyWith(CustomException value, $Res Function(CustomException) _then) = _$CustomExceptionCopyWithImpl;
@useResult
$Res call({
 String message, StackTrace? stackTrace
});




}
/// @nodoc
class _$CustomExceptionCopyWithImpl<$Res>
    implements $CustomExceptionCopyWith<$Res> {
  _$CustomExceptionCopyWithImpl(this._self, this._then);

  final CustomException _self;
  final $Res Function(CustomException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? message = null,Object? stackTrace = freezed,}) {
  return _then(_self.copyWith(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}

}


/// Adds pattern-matching-related methods to [CustomException].
extension CustomExceptionPatterns on CustomException {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( ParsingException value)?  parsing,TResult Function( ValidationException value)?  validation,TResult Function( IllegalOperationException value)?  illegalOperation,TResult Function( NotFoundException value)?  notFound,TResult Function( UnauthorizedException value)?  unauthorized,TResult Function( UnknownException value)?  unknown,required TResult orElse(),}){
final _that = this;
switch (_that) {
case ParsingException() when parsing != null:
return parsing(_that);case ValidationException() when validation != null:
return validation(_that);case IllegalOperationException() when illegalOperation != null:
return illegalOperation(_that);case NotFoundException() when notFound != null:
return notFound(_that);case UnauthorizedException() when unauthorized != null:
return unauthorized(_that);case UnknownException() when unknown != null:
return unknown(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( ParsingException value)  parsing,required TResult Function( ValidationException value)  validation,required TResult Function( IllegalOperationException value)  illegalOperation,required TResult Function( NotFoundException value)  notFound,required TResult Function( UnauthorizedException value)  unauthorized,required TResult Function( UnknownException value)  unknown,}){
final _that = this;
switch (_that) {
case ParsingException():
return parsing(_that);case ValidationException():
return validation(_that);case IllegalOperationException():
return illegalOperation(_that);case NotFoundException():
return notFound(_that);case UnauthorizedException():
return unauthorized(_that);case UnknownException():
return unknown(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( ParsingException value)?  parsing,TResult? Function( ValidationException value)?  validation,TResult? Function( IllegalOperationException value)?  illegalOperation,TResult? Function( NotFoundException value)?  notFound,TResult? Function( UnauthorizedException value)?  unauthorized,TResult? Function( UnknownException value)?  unknown,}){
final _that = this;
switch (_that) {
case ParsingException() when parsing != null:
return parsing(_that);case ValidationException() when validation != null:
return validation(_that);case IllegalOperationException() when illegalOperation != null:
return illegalOperation(_that);case NotFoundException() when notFound != null:
return notFound(_that);case UnauthorizedException() when unauthorized != null:
return unauthorized(_that);case UnknownException() when unknown != null:
return unknown(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( String message,  String? field,  Object? originalError,  StackTrace? stackTrace)?  parsing,TResult Function( String message,  String field,  Map<String, dynamic>? errors,  StackTrace? stackTrace)?  validation,TResult Function( String message,  String? operation,  String? reason,  StackTrace? stackTrace)?  illegalOperation,TResult Function( String message,  String? resource,  String? identifier,  StackTrace? stackTrace)?  notFound,TResult Function( String message,  String? requiredPermission,  StackTrace? stackTrace)?  unauthorized,TResult Function( String message,  Object? originalError,  StackTrace? stackTrace)?  unknown,required TResult orElse(),}) {final _that = this;
switch (_that) {
case ParsingException() when parsing != null:
return parsing(_that.message,_that.field,_that.originalError,_that.stackTrace);case ValidationException() when validation != null:
return validation(_that.message,_that.field,_that.errors,_that.stackTrace);case IllegalOperationException() when illegalOperation != null:
return illegalOperation(_that.message,_that.operation,_that.reason,_that.stackTrace);case NotFoundException() when notFound != null:
return notFound(_that.message,_that.resource,_that.identifier,_that.stackTrace);case UnauthorizedException() when unauthorized != null:
return unauthorized(_that.message,_that.requiredPermission,_that.stackTrace);case UnknownException() when unknown != null:
return unknown(_that.message,_that.originalError,_that.stackTrace);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( String message,  String? field,  Object? originalError,  StackTrace? stackTrace)  parsing,required TResult Function( String message,  String field,  Map<String, dynamic>? errors,  StackTrace? stackTrace)  validation,required TResult Function( String message,  String? operation,  String? reason,  StackTrace? stackTrace)  illegalOperation,required TResult Function( String message,  String? resource,  String? identifier,  StackTrace? stackTrace)  notFound,required TResult Function( String message,  String? requiredPermission,  StackTrace? stackTrace)  unauthorized,required TResult Function( String message,  Object? originalError,  StackTrace? stackTrace)  unknown,}) {final _that = this;
switch (_that) {
case ParsingException():
return parsing(_that.message,_that.field,_that.originalError,_that.stackTrace);case ValidationException():
return validation(_that.message,_that.field,_that.errors,_that.stackTrace);case IllegalOperationException():
return illegalOperation(_that.message,_that.operation,_that.reason,_that.stackTrace);case NotFoundException():
return notFound(_that.message,_that.resource,_that.identifier,_that.stackTrace);case UnauthorizedException():
return unauthorized(_that.message,_that.requiredPermission,_that.stackTrace);case UnknownException():
return unknown(_that.message,_that.originalError,_that.stackTrace);}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( String message,  String? field,  Object? originalError,  StackTrace? stackTrace)?  parsing,TResult? Function( String message,  String field,  Map<String, dynamic>? errors,  StackTrace? stackTrace)?  validation,TResult? Function( String message,  String? operation,  String? reason,  StackTrace? stackTrace)?  illegalOperation,TResult? Function( String message,  String? resource,  String? identifier,  StackTrace? stackTrace)?  notFound,TResult? Function( String message,  String? requiredPermission,  StackTrace? stackTrace)?  unauthorized,TResult? Function( String message,  Object? originalError,  StackTrace? stackTrace)?  unknown,}) {final _that = this;
switch (_that) {
case ParsingException() when parsing != null:
return parsing(_that.message,_that.field,_that.originalError,_that.stackTrace);case ValidationException() when validation != null:
return validation(_that.message,_that.field,_that.errors,_that.stackTrace);case IllegalOperationException() when illegalOperation != null:
return illegalOperation(_that.message,_that.operation,_that.reason,_that.stackTrace);case NotFoundException() when notFound != null:
return notFound(_that.message,_that.resource,_that.identifier,_that.stackTrace);case UnauthorizedException() when unauthorized != null:
return unauthorized(_that.message,_that.requiredPermission,_that.stackTrace);case UnknownException() when unknown != null:
return unknown(_that.message,_that.originalError,_that.stackTrace);case _:
  return null;

}
}

}

/// @nodoc


class ParsingException implements CustomException {
  const ParsingException({required this.message, this.field, this.originalError, this.stackTrace});
  

@override final  String message;
 final  String? field;
 final  Object? originalError;
@override final  StackTrace? stackTrace;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsingExceptionCopyWith<ParsingException> get copyWith => _$ParsingExceptionCopyWithImpl<ParsingException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsingException&&(identical(other.message, message) || other.message == message)&&(identical(other.field, field) || other.field == field)&&const DeepCollectionEquality().equals(other.originalError, originalError)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,field,const DeepCollectionEquality().hash(originalError),stackTrace);

@override
String toString() {
  return 'CustomException.parsing(message: $message, field: $field, originalError: $originalError, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $ParsingExceptionCopyWith<$Res> implements $CustomExceptionCopyWith<$Res> {
  factory $ParsingExceptionCopyWith(ParsingException value, $Res Function(ParsingException) _then) = _$ParsingExceptionCopyWithImpl;
@override @useResult
$Res call({
 String message, String? field, Object? originalError, StackTrace? stackTrace
});




}
/// @nodoc
class _$ParsingExceptionCopyWithImpl<$Res>
    implements $ParsingExceptionCopyWith<$Res> {
  _$ParsingExceptionCopyWithImpl(this._self, this._then);

  final ParsingException _self;
  final $Res Function(ParsingException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? field = freezed,Object? originalError = freezed,Object? stackTrace = freezed,}) {
  return _then(ParsingException(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,field: freezed == field ? _self.field : field // ignore: cast_nullable_to_non_nullable
as String?,originalError: freezed == originalError ? _self.originalError : originalError ,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}


}

/// @nodoc


class ValidationException implements CustomException {
  const ValidationException({required this.message, required this.field, final  Map<String, dynamic>? errors, this.stackTrace}): _errors = errors;
  

@override final  String message;
 final  String field;
 final  Map<String, dynamic>? _errors;
 Map<String, dynamic>? get errors {
  final value = _errors;
  if (value == null) return null;
  if (_errors is EqualUnmodifiableMapView) return _errors;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

@override final  StackTrace? stackTrace;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ValidationExceptionCopyWith<ValidationException> get copyWith => _$ValidationExceptionCopyWithImpl<ValidationException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ValidationException&&(identical(other.message, message) || other.message == message)&&(identical(other.field, field) || other.field == field)&&const DeepCollectionEquality().equals(other._errors, _errors)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,field,const DeepCollectionEquality().hash(_errors),stackTrace);

@override
String toString() {
  return 'CustomException.validation(message: $message, field: $field, errors: $errors, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $ValidationExceptionCopyWith<$Res> implements $CustomExceptionCopyWith<$Res> {
  factory $ValidationExceptionCopyWith(ValidationException value, $Res Function(ValidationException) _then) = _$ValidationExceptionCopyWithImpl;
@override @useResult
$Res call({
 String message, String field, Map<String, dynamic>? errors, StackTrace? stackTrace
});




}
/// @nodoc
class _$ValidationExceptionCopyWithImpl<$Res>
    implements $ValidationExceptionCopyWith<$Res> {
  _$ValidationExceptionCopyWithImpl(this._self, this._then);

  final ValidationException _self;
  final $Res Function(ValidationException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? field = null,Object? errors = freezed,Object? stackTrace = freezed,}) {
  return _then(ValidationException(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,field: null == field ? _self.field : field // ignore: cast_nullable_to_non_nullable
as String,errors: freezed == errors ? _self._errors : errors // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}


}

/// @nodoc


class IllegalOperationException implements CustomException {
  const IllegalOperationException({required this.message, this.operation, this.reason, this.stackTrace});
  

@override final  String message;
 final  String? operation;
 final  String? reason;
@override final  StackTrace? stackTrace;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$IllegalOperationExceptionCopyWith<IllegalOperationException> get copyWith => _$IllegalOperationExceptionCopyWithImpl<IllegalOperationException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is IllegalOperationException&&(identical(other.message, message) || other.message == message)&&(identical(other.operation, operation) || other.operation == operation)&&(identical(other.reason, reason) || other.reason == reason)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,operation,reason,stackTrace);

@override
String toString() {
  return 'CustomException.illegalOperation(message: $message, operation: $operation, reason: $reason, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $IllegalOperationExceptionCopyWith<$Res> implements $CustomExceptionCopyWith<$Res> {
  factory $IllegalOperationExceptionCopyWith(IllegalOperationException value, $Res Function(IllegalOperationException) _then) = _$IllegalOperationExceptionCopyWithImpl;
@override @useResult
$Res call({
 String message, String? operation, String? reason, StackTrace? stackTrace
});




}
/// @nodoc
class _$IllegalOperationExceptionCopyWithImpl<$Res>
    implements $IllegalOperationExceptionCopyWith<$Res> {
  _$IllegalOperationExceptionCopyWithImpl(this._self, this._then);

  final IllegalOperationException _self;
  final $Res Function(IllegalOperationException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? operation = freezed,Object? reason = freezed,Object? stackTrace = freezed,}) {
  return _then(IllegalOperationException(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,operation: freezed == operation ? _self.operation : operation // ignore: cast_nullable_to_non_nullable
as String?,reason: freezed == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as String?,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}


}

/// @nodoc


class NotFoundException implements CustomException {
  const NotFoundException({required this.message, this.resource, this.identifier, this.stackTrace});
  

@override final  String message;
 final  String? resource;
 final  String? identifier;
@override final  StackTrace? stackTrace;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotFoundExceptionCopyWith<NotFoundException> get copyWith => _$NotFoundExceptionCopyWithImpl<NotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotFoundException&&(identical(other.message, message) || other.message == message)&&(identical(other.resource, resource) || other.resource == resource)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,resource,identifier,stackTrace);

@override
String toString() {
  return 'CustomException.notFound(message: $message, resource: $resource, identifier: $identifier, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $NotFoundExceptionCopyWith<$Res> implements $CustomExceptionCopyWith<$Res> {
  factory $NotFoundExceptionCopyWith(NotFoundException value, $Res Function(NotFoundException) _then) = _$NotFoundExceptionCopyWithImpl;
@override @useResult
$Res call({
 String message, String? resource, String? identifier, StackTrace? stackTrace
});




}
/// @nodoc
class _$NotFoundExceptionCopyWithImpl<$Res>
    implements $NotFoundExceptionCopyWith<$Res> {
  _$NotFoundExceptionCopyWithImpl(this._self, this._then);

  final NotFoundException _self;
  final $Res Function(NotFoundException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? resource = freezed,Object? identifier = freezed,Object? stackTrace = freezed,}) {
  return _then(NotFoundException(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,resource: freezed == resource ? _self.resource : resource // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}


}

/// @nodoc


class UnauthorizedException implements CustomException {
  const UnauthorizedException({required this.message, this.requiredPermission, this.stackTrace});
  

@override final  String message;
 final  String? requiredPermission;
@override final  StackTrace? stackTrace;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnauthorizedExceptionCopyWith<UnauthorizedException> get copyWith => _$UnauthorizedExceptionCopyWithImpl<UnauthorizedException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnauthorizedException&&(identical(other.message, message) || other.message == message)&&(identical(other.requiredPermission, requiredPermission) || other.requiredPermission == requiredPermission)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,requiredPermission,stackTrace);

@override
String toString() {
  return 'CustomException.unauthorized(message: $message, requiredPermission: $requiredPermission, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $UnauthorizedExceptionCopyWith<$Res> implements $CustomExceptionCopyWith<$Res> {
  factory $UnauthorizedExceptionCopyWith(UnauthorizedException value, $Res Function(UnauthorizedException) _then) = _$UnauthorizedExceptionCopyWithImpl;
@override @useResult
$Res call({
 String message, String? requiredPermission, StackTrace? stackTrace
});




}
/// @nodoc
class _$UnauthorizedExceptionCopyWithImpl<$Res>
    implements $UnauthorizedExceptionCopyWith<$Res> {
  _$UnauthorizedExceptionCopyWithImpl(this._self, this._then);

  final UnauthorizedException _self;
  final $Res Function(UnauthorizedException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? requiredPermission = freezed,Object? stackTrace = freezed,}) {
  return _then(UnauthorizedException(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,requiredPermission: freezed == requiredPermission ? _self.requiredPermission : requiredPermission // ignore: cast_nullable_to_non_nullable
as String?,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}


}

/// @nodoc


class UnknownException implements CustomException {
  const UnknownException({required this.message, this.originalError, this.stackTrace});
  

@override final  String message;
 final  Object? originalError;
@override final  StackTrace? stackTrace;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnknownExceptionCopyWith<UnknownException> get copyWith => _$UnknownExceptionCopyWithImpl<UnknownException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnknownException&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other.originalError, originalError)&&(identical(other.stackTrace, stackTrace) || other.stackTrace == stackTrace));
}


@override
int get hashCode => Object.hash(runtimeType,message,const DeepCollectionEquality().hash(originalError),stackTrace);

@override
String toString() {
  return 'CustomException.unknown(message: $message, originalError: $originalError, stackTrace: $stackTrace)';
}


}

/// @nodoc
abstract mixin class $UnknownExceptionCopyWith<$Res> implements $CustomExceptionCopyWith<$Res> {
  factory $UnknownExceptionCopyWith(UnknownException value, $Res Function(UnknownException) _then) = _$UnknownExceptionCopyWithImpl;
@override @useResult
$Res call({
 String message, Object? originalError, StackTrace? stackTrace
});




}
/// @nodoc
class _$UnknownExceptionCopyWithImpl<$Res>
    implements $UnknownExceptionCopyWith<$Res> {
  _$UnknownExceptionCopyWithImpl(this._self, this._then);

  final UnknownException _self;
  final $Res Function(UnknownException) _then;

/// Create a copy of CustomException
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? originalError = freezed,Object? stackTrace = freezed,}) {
  return _then(UnknownException(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,originalError: freezed == originalError ? _self.originalError : originalError ,stackTrace: freezed == stackTrace ? _self.stackTrace : stackTrace // ignore: cast_nullable_to_non_nullable
as StackTrace?,
  ));
}


}

// dart format on


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/base/repository.dart repository.dart
import '../logger/log.dart';
import 'failure.dart';
import 'result.dart';

abstract base class Repository<T> {
  /// Executes an asynchronous operation and wraps the result in a [Result]
  /// type.
  ///
  /// This method provides a safe way to handle asynchronous operations by
  /// catching any exceptions that occur during execution and converting them to
  /// [Failure] objects wrapped in an [Error] result.
  ///
  /// Parameters:
  /// - [operation]: A function that returns a [Future<T>] to be executed
  ///
  /// Returns:
  /// - [Success<T>] if the operation completes successfully
  /// - [Error<Failure>] if an exception occurs during execution
  ///
  /// Example:
  /// ```dart
  /// final result = await asyncGuard(() async {
  ///   return await apiService.fetchData();
  /// });
  ///
  /// result.when(
  ///   success: (data) => print('Data: $data'),
  ///   error: (failure) => print('Error: ${failure.message}'),
  /// );
  /// ```
  // ignore: avoid_shadowing_type_parameters
  Future<Result<T, Failure>> asyncGuard<T>(
    Future<T> Function() operation,
  ) async {
    try {
      final result = await operation();
      return Success(data: result);
    } on Exception catch (e, stackTrace) {
      Log.error(e.toString());
      Log.error(stackTrace.toString());

      return Error(Failure.mapExceptionToFailure(e));
    }
  }

  /// Executes a synchronous operation and wraps the result in a [Result] type.
  ///
  /// This method provides a safe way to handle synchronous operations by
  /// catching any exceptions that occur during execution and converting them to
  /// [Failure] objects wrapped in an [Error] result.
  ///
  /// Parameters:
  /// - [operation]: A function that returns a value of type [T] to be executed
  ///
  /// Returns:
  /// - [Success<T>] if the operation completes successfully
  /// - [Error<Failure>] if an exception occurs during execution
  ///
  /// Example:
  /// ```dart
  /// final result = guard(() {
  ///   return jsonDecode(jsonString);
  /// });
  ///
  /// result.when(
  ///   success: (data) => print('Parsed data: $data'),
  ///   error: (failure) => print('Parsing error: ${failure.message}'),
  /// );
  /// ```
  Result<T, Failure> guard(T Function() operation) {
    try {
      final result = operation();
      return Success(data: result);
    } on Exception catch (e) {
      return Error(Failure.mapExceptionToFailure(e));
    }
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/base/exceptions.dart exceptions.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'exceptions.freezed.dart';

@freezed
sealed class CustomException with _$CustomException {
  const factory CustomException.parsing({
    required String message,
    String? field,
    Object? originalError,
    StackTrace? stackTrace,
  }) = ParsingException;

  const factory CustomException.validation({
    required String message,
    required String field,
    Map<String, dynamic>? errors,
    StackTrace? stackTrace,
  }) = ValidationException;

  const factory CustomException.illegalOperation({
    required String message,
    String? operation,
    String? reason,
    StackTrace? stackTrace,
  }) = IllegalOperationException;

  const factory CustomException.notFound({
    required String message,
    String? resource,
    String? identifier,
    StackTrace? stackTrace,
  }) = NotFoundException;

  const factory CustomException.unauthorized({
    required String message,
    String? requiredPermission,
    StackTrace? stackTrace,
  }) = UnauthorizedException;

  const factory CustomException.unknown({
    required String message,
    Object? originalError,
    StackTrace? stackTrace,
  }) = UnknownException;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/base/result.dart result.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'result.freezed.dart';

@freezed
class Result<T, E> with _$Result<T, E> {
  const factory Result.success({T? data}) = Success;
  const factory Result.error(E error) = Error;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/base/result.freezed.dart result.freezed.dart
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$Result<T,E> {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Result<T, E>);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'Result<$T, $E>()';
}


}

/// @nodoc
class $ResultCopyWith<T,E,$Res>  {
$ResultCopyWith(Result<T, E> _, $Res Function(Result<T, E>) __);
}


/// Adds pattern-matching-related methods to [Result].
extension ResultPatterns<T,E> on Result<T, E> {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( Success<T, E> value)?  success,TResult Function( Error<T, E> value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case Success() when success != null:
return success(_that);case Error() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( Success<T, E> value)  success,required TResult Function( Error<T, E> value)  error,}){
final _that = this;
switch (_that) {
case Success():
return success(_that);case Error():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( Success<T, E> value)?  success,TResult? Function( Error<T, E> value)?  error,}){
final _that = this;
switch (_that) {
case Success() when success != null:
return success(_that);case Error() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( T? data)?  success,TResult Function( E error)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case Success() when success != null:
return success(_that.data);case Error() when error != null:
return error(_that.error);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( T? data)  success,required TResult Function( E error)  error,}) {final _that = this;
switch (_that) {
case Success():
return success(_that.data);case Error():
return error(_that.error);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( T? data)?  success,TResult? Function( E error)?  error,}) {final _that = this;
switch (_that) {
case Success() when success != null:
return success(_that.data);case Error() when error != null:
return error(_that.error);case _:
  return null;

}
}

}

/// @nodoc


class Success<T,E> implements Result<T, E> {
  const Success({this.data});
  

 final  T? data;

/// Create a copy of Result
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SuccessCopyWith<T, E, Success<T, E>> get copyWith => _$SuccessCopyWithImpl<T, E, Success<T, E>>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Success<T, E>&&const DeepCollectionEquality().equals(other.data, data));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'Result<$T, $E>.success(data: $data)';
}


}

/// @nodoc
abstract mixin class $SuccessCopyWith<T,E,$Res> implements $ResultCopyWith<T, E, $Res> {
  factory $SuccessCopyWith(Success<T, E> value, $Res Function(Success<T, E>) _then) = _$SuccessCopyWithImpl;
@useResult
$Res call({
 T? data
});




}
/// @nodoc
class _$SuccessCopyWithImpl<T,E,$Res>
    implements $SuccessCopyWith<T, E, $Res> {
  _$SuccessCopyWithImpl(this._self, this._then);

  final Success<T, E> _self;
  final $Res Function(Success<T, E>) _then;

/// Create a copy of Result
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = freezed,}) {
  return _then(Success<T, E>(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as T?,
  ));
}


}

/// @nodoc


class Error<T,E> implements Result<T, E> {
  const Error(this.error);
  

 final  E error;

/// Create a copy of Result
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ErrorCopyWith<T, E, Error<T, E>> get copyWith => _$ErrorCopyWithImpl<T, E, Error<T, E>>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Error<T, E>&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'Result<$T, $E>.error(error: $error)';
}


}

/// @nodoc
abstract mixin class $ErrorCopyWith<T,E,$Res> implements $ResultCopyWith<T, E, $Res> {
  factory $ErrorCopyWith(Error<T, E> value, $Res Function(Error<T, E>) _then) = _$ErrorCopyWithImpl;
@useResult
$Res call({
 E error
});




}
/// @nodoc
class _$ErrorCopyWithImpl<T,E,$Res>
    implements $ErrorCopyWith<T, E, $Res> {
  _$ErrorCopyWithImpl(this._self, this._then);

  final Error<T, E> _self;
  final $Res Function(Error<T, E>) _then;

/// Create a copy of Result
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(Error<T, E>(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as E,
  ));
}


}

// dart format on


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/base/base.dart base.dart
export 'failure.dart';
export 'repository.dart';
export 'result.dart';


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/logger/log.dart log.dart
import 'package:logger/logger.dart';

class Log {
  Log._internal() {
    _logger = Logger(
      printer: PrettyPrinter(
        methodCount: 2,
        // number of method calls to be displayed
        errorMethodCount: 8,
        // number of method calls if stacktrace is provided
        lineLength: lineLength,
        // width of the output
        colors: true,
        // Colorful log messages
        printEmojis: true,
        // Print an emoji for each log message
        dateTimeFormat: DateTimeFormat.none, // No timestamp in log messages
      ),
    );
  }

  static final Log _singleton = Log._internal();

  late Logger _logger;
  static const lineLength = 80;

  static void fatal({required Object error, required StackTrace stackTrace}) =>
      _singleton._logger.f('Fatal', error: error, stackTrace: stackTrace);

  static void debug(String message) => _singleton._logger.d(message);

  static void info(String message) => _singleton._logger.i(message);

  static void error(String message) => _singleton._logger.e(message);

  static void warning(String message) => _singleton._logger.w(message);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/logger/riverpod_log.dart riverpod_log.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'log.dart';

class RiverpodObserver extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase<Object?> provider,
    Object? value,
    ProviderContainer container,
  ) {
    Log.info('Provider $provider was initialized with $value');
  }

  @override
  void didDisposeProvider(
    ProviderBase<Object?> provider,
    ProviderContainer container,
  ) {
    Log.warning('Provider $provider was disposed');
  }

  @override
  void didUpdateProvider(
    ProviderBase<Object?> provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    Log.info('Provider $provider updated from $previousValue to $newValue');
  }

  @override
  void providerDidFail(
    ProviderBase<Object?> provider,
    Object error,
    StackTrace stackTrace,
    ProviderContainer container,
  ) {
    Log.error('Provider $provider threw $error at $stackTrace');
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/localization/intl_bn.arb intl_bn.arb
{
    "english": "English",
    "bangla": "বাংলা",
    "arabic": "العربية",
    "home": "হোম",
    "profile": "প্রোফাইল",
    "login": "লগইন",
    "createNewPassword": "নতুন পাসওয়ার্ড তৈরি করুন",
    "createNewPasswordHint": "আপনার নতুন পাসওয়ার্ড আগে ব্যবহৃত পাসওয়ার্ড থেকে আলাদা হতে হবে।",
    "resetPassword": "পাসওয়ার্ড রিসেট করুন",
    "newPassword": "নতুন পাসওয়ার্ড",
    "passwordChangeSuccess": "পাসওয়ার্ড সফলভাবে পরিবর্তন করা হয়েছে",
    "emailRequired": "ইমেইল প্রয়োজন",
    "passwordRequired": "পাসওয়ার্ড প্রয়োজন",
    "isRequired": "এই ক্ষেত্রটি প্রয়োজন",
    "validEmail": "অনুগ্রহ করে একটি বৈধ ইমেইল ঠিকানা দিন",
    "enterAssociatedEmail": "আপনার অ্যাকাউন্টের সাথে যুক্ত ইমেইল দিন এবং আমরা আপনার পাসওয়ার্ড রিসেট করার নির্দেশনা সহ একটি ইমেইল পাঠাব।",
    "minLengthValidation": "এই ক্ষেত্রটি কমপক্ষে {min} অক্ষর দীর্ঘ হতে হবে",
    "@minLengthValidation": {
        "description": "ন্যূনতম দৈর্ঘ্য যাচাইকরণের জন্য ত্রুটি বার্তা",
        "placeholders": {
            "min": {
                "type": "int",
                "example": "৩"
            }
        }
    },
    "maxLengthValidation": "এই ক্ষেত্রটি সর্বাধিক {max} অক্ষর দীর্ঘ হতে হবে",
    "@maxLengthValidation": {
        "description": "সর্বোচ্চ দৈর্ঘ্য যাচাইকরণের জন্য ত্রুটি বার্তা",
        "placeholders": {
            "max": {
                "type": "int",
                "example": "২০"
            }
        }
    },
    "yourPasswordChanged": "আপনার পাসওয়ার্ড সফলভাবে পরিবর্তন করা হয়েছে।",
    "confirmPassword": "পাসওয়ার্ড নিশ্চিত করুন",
    "logout": "লগআউট",
    "getStarted": "শুরু করুন",
    "rememberMe": "আমাকে মনে রাখুন",
    "forgotPassword": "পাসওয়ার্ড ভুলে গেছেন",
    "backToLogin": "লগইনে ফিরে যান",
    "continueAction": "চালিয়ে যান",
    "signUp": "সাইন আপ",
    "signIn": "সাইন ইন",
    "email": "ইমেইল",
    "emailAddress": "ইমেইল ঠিকানা",
    "password": "পাসওয়ার্ড",
    "firstName": "প্রথম নাম",
    "lastName": "শেষ নাম",
    "dontHaveAccount": "অ্যাকাউন্ট নেই? ",
    "alreadyHaveAccount": "ইতিমধ্যে অ্যাকাউন্ট আছে? ",
    "checkYourMail": "আপনার মেইল চেক করুন",
    "enterVerificationCode": "অনুগ্রহ করে আপনার মেইলে পাঠানো 4 অঙ্কের কোড দিন hello**@gmail.com।",
    "didntGetCode": "কোড পাননি? ",
    "clickToResend": "পুনরায় পাঠাতে ক্লিক করুন",
    "didNotReceiveEmail": "ইমেইল পাননি? আপনার স্প্যাম ফিল্টার চেক করুন। অথবা ",
    "tryAnotherEmail": "অন্য ইমেইল ঠিকানা চেষ্টা করুন",
    "learnFlutterTitle": "ব্যাপক টিউটোরিয়াল সহ Flutter শিখুন।",
    "learnFlutterSubtitle": "Flutter অ্যাপ তৈরি করার জন্য ধাপে ধাপে গাইড।",
    "learnFlutterDescription": "নতুন টিউটোরিয়াল এবং আপডেটের জন্য বিজ্ঞপ্তি পান।",
    "joinCommunityTitle": "Flutter সম্প্রদায়ে যোগ দিন।",
    "joinCommunitySubtitle": "অন্যান্য Flutter ডেভেলপারদের সাথে সংযুক্ত হন।",
    "joinCommunityDescription": "সম্প্রদায়ের ইভেন্ট এবং আলোচনায় অংশগ্রহণ করুন।",
    "buildDeployTitle": "সহজে Flutter অ্যাপ তৈরি এবং ডেপ্লয় করুন।",
    "buildDeploySubtitle": "অ্যাপ ডেভেলপমেন্টের জন্য টুল এবং সম্পদ অ্যাক্সেস করুন।",
    "buildDeployDescription": "সহজে একাধিক প্ল্যাটফর্মে আপনার অ্যাপ ডেপ্লয় করুন।",
    "passwordMinLengthValidation": "পাসওয়ার্ড কমপক্ষে {minLength} অক্ষর দীর্ঘ হতে হবে",
    "@passwordMinLengthValidation": {
        "description": "পাসওয়ার্ডের ন্যূনতম দৈর্ঘ্য যাচাইকরণের জন্য ত্রুটি বার্তা",
        "placeholders": {
            "minLength": {
                "type": "String"
            }
        }
    },
    "passwordNumberValidation": "পাসওয়ার্ডে কমপক্ষে একটি সংখ্যা থাকতে হবে",
    "passwordLowerCaseValidation": "পাসওয়ার্ডে কমপক্ষে একটি ছোট হাতের অক্ষর থাকতে হবে",
    "passwordUpperCaseValidation": "পাসওয়ার্ডে কমপক্ষে একটি বড় হাতের অক্ষর থাকতে হবে",
    "passwordSpecialCharValidation": "পাসওয়ার্ডে কমপক্ষে একটি বিশেষ অক্ষর থাকতে হবে"
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/localization/intl_ar.arb intl_ar.arb
{
    "english": "English",
    "bangla": "বাংলা",
    "arabic": "العربية",
    "home": "الرئيسية",
    "profile": "الملف الشخصي",
    "login": "تسجيل الدخول",
    "createNewPassword": "إنشاء كلمة مرور جديدة",
    "createNewPasswordHint": "يجب أن تكون كلمة المرور الجديدة مختلفة عن كلمات المرور المستخدمة سابقاً.",
    "resetPassword": "إعادة تعيين كلمة المرور",
    "newPassword": "كلمة المرور الجديدة",
    "passwordChangeSuccess": "تم تغيير كلمة المرور بنجاح",
    "emailRequired": "البريد الإلكتروني مطلوب",
    "passwordRequired": "كلمة المرور مطلوبة",
    "isRequired": "هذا الحقل مطلوب",
    "validEmail": "يرجى إدخال عنوان بريد إلكتروني صحيح",
    "enterAssociatedEmail": "أدخل البريد الإلكتروني المرتبط بحسابك وسنرسل لك بريداً إلكترونياً مع تعليمات لإعادة تعيين كلمة المرور.",
    "minLengthValidation": "يجب أن يحتوي هذا الحقل على {min} أحرف على الأقل",
    "@minLengthValidation": {
        "description": "رسالة خطأ للتحقق من الحد الأدنى للطول",
        "placeholders": {
            "min": {
                "type": "int",
                "example": "٣"
            }
        }
    },
    "maxLengthValidation": "يجب أن يحتوي هذا الحقل على {max} أحرف كحد أقصى",
    "@maxLengthValidation": {
        "description": "رسالة خطأ للتحقق من الحد الأقصى للطول",
        "placeholders": {
            "max": {
                "type": "int",
                "example": "٢٠"
            }
        }
    },
    "yourPasswordChanged": "تم تغيير كلمة المرور بنجاح.",
    "confirmPassword": "تأكيد كلمة المرور",
    "logout": "تسجيل الخروج",
    "getStarted": "ابدأ",
    "rememberMe": "تذكرني",
    "forgotPassword": "نسيت كلمة المرور",
    "backToLogin": "العودة إلى تسجيل الدخول",
    "continueAction": "متابعة",
    "signUp": "إنشاء حساب",
    "signIn": "تسجيل الدخول",
    "email": "البريد الإلكتروني",
    "emailAddress": "عنوان البريد الإلكتروني",
    "password": "كلمة المرور",
    "firstName": "الاسم الأول",
    "lastName": "اسم العائلة",
    "dontHaveAccount": "ليس لديك حساب؟ ",
    "alreadyHaveAccount": "لديك حساب بالفعل؟ ",
    "checkYourMail": "تحقق من بريدك الإلكتروني",
    "enterVerificationCode": "يرجى إدخال الرمز المكون من 4 أرقام المرسل إلى بريدك الإلكتروني hello**@gmail.com.",
    "didntGetCode": "لم تحصل على رمز؟ ",
    "clickToResend": "انقر لإعادة الإرسال",
    "didNotReceiveEmail": "لم تستلم البريد الإلكتروني؟ تحقق من مجلد الرسائل غير المرغوب فيها. أو ",
    "tryAnotherEmail": "جرب عنوان بريد إلكتروني آخر",
    "learnFlutterTitle": "تعلم Flutter مع دروس شاملة.",
    "learnFlutterSubtitle": "دليل خطوة بخطوة لبناء تطبيقات Flutter.",
    "learnFlutterDescription": "احصل على إشعارات للدروس الجديدة والتحديثات.",
    "joinCommunityTitle": "انضم إلى مجتمع Flutter.",
    "joinCommunitySubtitle": "تواصل مع مطوري Flutter الآخرين.",
    "joinCommunityDescription": "شارك في أحداث المجتمع والمناقشات.",
    "buildDeployTitle": "ابن ونشر تطبيقات Flutter بسهولة.",
    "buildDeploySubtitle": "احصل على أدوات وموارد لتطوير التطبيقات.",
    "buildDeployDescription": "انشر تطبيقاتك على منصات متعددة بسهولة.",
    "passwordMinLengthValidation": "يجب أن تحتوي كلمة المرور على {minLength} أحرف على الأقل",
    "@passwordMinLengthValidation": {
        "description": "رسالة خطأ للتحقق من الحد الأدنى لطول كلمة المرور",
        "placeholders": {
            "minLength": {
                "type": "String"
            }
        }
    },
    "passwordNumberValidation": "يجب أن تحتوي كلمة المرور على رقم واحد على الأقل",
    "passwordLowerCaseValidation": "يجب أن تحتوي كلمة المرور على حرف صغير واحد على الأقل",
    "passwordUpperCaseValidation": "يجب أن تحتوي كلمة المرور على حرف كبير واحد على الأقل",
    "passwordSpecialCharValidation": "يجب أن تحتوي كلمة المرور على رمز خاص واحد على الأقل"
}

================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/localization/intl_en.arb intl_en.arb
{
    "english": "English",
    "bangla": "বাংলা",
    "arabic": "العربية",
    "home": "Home",
    "profile": "Profile",
    "login": "Login",
    "createNewPassword": "Create New password",
    "createNewPasswordHint": "Your new password must be different from previous used passwords.",
    "resetPassword": "Reset Password",
    "newPassword": "New Password",
    "passwordChangeSuccess":"Password Changed Successfully",
    "emailRequired": "Email is required",
    "passwordRequired": "Password is required",
    "isRequired": "This field is required",
    "validEmail": "Please enter valid email address",
    "enterAssociatedEmail": "Enter the email associated with your account and we’ll send an email with instructions to reset your password.",
    "minLengthValidation": "This field must be at least {min} characters long",
    "@minLengthValidation": {
        "description": "Error message for minimum length validation",
        "placeholders": {
            "min": {
                "type": "int",
                "example": "3"
            }
        }
    },
    "maxLengthValidation": "This field must be at most {max} characters long",
    "@maxLengthValidation": {
        "description": "Error message for maximum length validation",
        "placeholders": {
            "max": {
                "type": "int",
                "example": "20"
            }
        }
    },
    "yourPasswordChanged": "Your password has been changed successfully.",
    "confirmPassword": "Confirm Password",
    "logout": "Logout",
    "getStarted": "Get Started",
    "rememberMe": "Remember me",
    "forgotPassword": "Forgot password",
    "backToLogin": "Back to login",
    "continueAction": "Continue",
    "signUp": "Sign up",
    "signIn": "Sign in",
    "email": "Email",
    "emailAddress": "Email Address",
    "password": "Password",
    "firstName": "First Name",
    "lastName": "Last Name",
    "dontHaveAccount": "Don't have an account? ",
    "alreadyHaveAccount": "Already have an account? ",
    "checkYourMail": "Check your mail",
    "enterVerificationCode": "Please enter 4 digit code sent to your mail hello**@gmail.com.",
    "didntGetCode": "Didn't get a code? ",
    "clickToResend": "Click to resend",
    "didNotReceiveEmail": "Did not receive the email? Check your spam filter. or ",
    "tryAnotherEmail": "try another email address",
    "learnFlutterTitle": "Learn Flutter with comprehensive tutorials.",
    "learnFlutterSubtitle": "Step-by-step guides for building Flutter apps.",
    "learnFlutterDescription": "Get notifications for new tutorials and updates.",
    "joinCommunityTitle": "Join the Flutter community.",
    "joinCommunitySubtitle": "Connect with other Flutter developers.",
    "joinCommunityDescription": "Participate in community events and discussions.",
    "buildDeployTitle": "Build and deploy Flutter apps easily.",
    "buildDeploySubtitle": "Access tools and resources for app development.",
    "buildDeployDescription": "Deploy your apps to multiple platforms with ease.",
    "passwordMinLengthValidation": "Password must be at least {minLength} characters",
    "@passwordMinLengthValidation": {
        "description": "Error message for password minimum length validation",
        "placeholders": {
            "minLength": {
                "type": "String"
            }
        }
    },
    "passwordNumberValidation": "Password must contain at least one number",
    "passwordLowerCaseValidation": "Password must contain at least one lowercase letter",
    "passwordUpperCaseValidation": "Password must contain at least one uppercase letter",
    "passwordSpecialCharValidation": "Password must contain at least one special character"
}

================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/gen/l10n/app_localizations_bn.dart app_localizations_bn.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Bengali Bangla (`bn`).
class AppLocalizationsBn extends AppLocalizations {
  AppLocalizationsBn([String locale = 'bn']) : super(locale);

  @override
  String get english => 'English';

  @override
  String get bangla => 'বাংলা';

  @override
  String get arabic => 'العربية';

  @override
  String get home => 'হোম';

  @override
  String get profile => 'প্রোফাইল';

  @override
  String get login => 'লগইন';

  @override
  String get createNewPassword => 'নতুন পাসওয়ার্ড তৈরি করুন';

  @override
  String get createNewPasswordHint =>
      'আপনার নতুন পাসওয়ার্ড আগে ব্যবহৃত পাসওয়ার্ড থেকে আলাদা হতে হবে।';

  @override
  String get resetPassword => 'পাসওয়ার্ড রিসেট করুন';

  @override
  String get newPassword => 'নতুন পাসওয়ার্ড';

  @override
  String get passwordChangeSuccess => 'পাসওয়ার্ড সফলভাবে পরিবর্তন করা হয়েছে';

  @override
  String get emailRequired => 'ইমেইল প্রয়োজন';

  @override
  String get passwordRequired => 'পাসওয়ার্ড প্রয়োজন';

  @override
  String get isRequired => 'এই ক্ষেত্রটি প্রয়োজন';

  @override
  String get validEmail => 'অনুগ্রহ করে একটি বৈধ ইমেইল ঠিকানা দিন';

  @override
  String get enterAssociatedEmail =>
      'আপনার অ্যাকাউন্টের সাথে যুক্ত ইমেইল দিন এবং আমরা আপনার পাসওয়ার্ড রিসেট করার নির্দেশনা সহ একটি ইমেইল পাঠাব।';

  @override
  String minLengthValidation(int min) {
    return 'এই ক্ষেত্রটি কমপক্ষে $min অক্ষর দীর্ঘ হতে হবে';
  }

  @override
  String maxLengthValidation(int max) {
    return 'এই ক্ষেত্রটি সর্বাধিক $max অক্ষর দীর্ঘ হতে হবে';
  }

  @override
  String get yourPasswordChanged =>
      'আপনার পাসওয়ার্ড সফলভাবে পরিবর্তন করা হয়েছে।';

  @override
  String get confirmPassword => 'পাসওয়ার্ড নিশ্চিত করুন';

  @override
  String get logout => 'লগআউট';

  @override
  String get getStarted => 'শুরু করুন';

  @override
  String get rememberMe => 'আমাকে মনে রাখুন';

  @override
  String get forgotPassword => 'পাসওয়ার্ড ভুলে গেছেন';

  @override
  String get backToLogin => 'লগইনে ফিরে যান';

  @override
  String get continueAction => 'চালিয়ে যান';

  @override
  String get signUp => 'সাইন আপ';

  @override
  String get signIn => 'সাইন ইন';

  @override
  String get email => 'ইমেইল';

  @override
  String get emailAddress => 'ইমেইল ঠিকানা';

  @override
  String get password => 'পাসওয়ার্ড';

  @override
  String get firstName => 'প্রথম নাম';

  @override
  String get lastName => 'শেষ নাম';

  @override
  String get dontHaveAccount => 'অ্যাকাউন্ট নেই? ';

  @override
  String get alreadyHaveAccount => 'ইতিমধ্যে অ্যাকাউন্ট আছে? ';

  @override
  String get checkYourMail => 'আপনার মেইল চেক করুন';

  @override
  String get enterVerificationCode =>
      'অনুগ্রহ করে আপনার মেইলে পাঠানো 4 অঙ্কের কোড দিন hello**@gmail.com।';

  @override
  String get didntGetCode => 'কোড পাননি? ';

  @override
  String get clickToResend => 'পুনরায় পাঠাতে ক্লিক করুন';

  @override
  String get didNotReceiveEmail =>
      'ইমেইল পাননি? আপনার স্প্যাম ফিল্টার চেক করুন। অথবা ';

  @override
  String get tryAnotherEmail => 'অন্য ইমেইল ঠিকানা চেষ্টা করুন';

  @override
  String get learnFlutterTitle => 'ব্যাপক টিউটোরিয়াল সহ Flutter শিখুন।';

  @override
  String get learnFlutterSubtitle =>
      'Flutter অ্যাপ তৈরি করার জন্য ধাপে ধাপে গাইড।';

  @override
  String get learnFlutterDescription =>
      'নতুন টিউটোরিয়াল এবং আপডেটের জন্য বিজ্ঞপ্তি পান।';

  @override
  String get joinCommunityTitle => 'Flutter সম্প্রদায়ে যোগ দিন।';

  @override
  String get joinCommunitySubtitle =>
      'অন্যান্য Flutter ডেভেলপারদের সাথে সংযুক্ত হন।';

  @override
  String get joinCommunityDescription =>
      'সম্প্রদায়ের ইভেন্ট এবং আলোচনায় অংশগ্রহণ করুন।';

  @override
  String get buildDeployTitle => 'সহজে Flutter অ্যাপ তৈরি এবং ডেপ্লয় করুন।';

  @override
  String get buildDeploySubtitle =>
      'অ্যাপ ডেভেলপমেন্টের জন্য টুল এবং সম্পদ অ্যাক্সেস করুন।';

  @override
  String get buildDeployDescription =>
      'সহজে একাধিক প্ল্যাটফর্মে আপনার অ্যাপ ডেপ্লয় করুন।';

  @override
  String passwordMinLengthValidation(String minLength) {
    return 'পাসওয়ার্ড কমপক্ষে $minLength অক্ষর দীর্ঘ হতে হবে';
  }

  @override
  String get passwordNumberValidation =>
      'পাসওয়ার্ডে কমপক্ষে একটি সংখ্যা থাকতে হবে';

  @override
  String get passwordLowerCaseValidation =>
      'পাসওয়ার্ডে কমপক্ষে একটি ছোট হাতের অক্ষর থাকতে হবে';

  @override
  String get passwordUpperCaseValidation =>
      'পাসওয়ার্ডে কমপক্ষে একটি বড় হাতের অক্ষর থাকতে হবে';

  @override
  String get passwordSpecialCharValidation =>
      'পাসওয়ার্ডে কমপক্ষে একটি বিশেষ অক্ষর থাকতে হবে';
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/gen/l10n/app_localizations.dart app_localizations.dart
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_ar.dart';
import 'app_localizations_bn.dart';
import 'app_localizations_en.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'l10n/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale)
    : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations)!;
  }

  static const LocalizationsDelegate<AppLocalizations> delegate =
      _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates =
      <LocalizationsDelegate<dynamic>>[
        delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('ar'),
    Locale('bn'),
    Locale('en'),
  ];

  /// No description provided for @english.
  ///
  /// In en, this message translates to:
  /// **'English'**
  String get english;

  /// No description provided for @bangla.
  ///
  /// In en, this message translates to:
  /// **'বাংলা'**
  String get bangla;

  /// No description provided for @arabic.
  ///
  /// In en, this message translates to:
  /// **'العربية'**
  String get arabic;

  /// No description provided for @home.
  ///
  /// In en, this message translates to:
  /// **'Home'**
  String get home;

  /// No description provided for @profile.
  ///
  /// In en, this message translates to:
  /// **'Profile'**
  String get profile;

  /// No description provided for @login.
  ///
  /// In en, this message translates to:
  /// **'Login'**
  String get login;

  /// No description provided for @createNewPassword.
  ///
  /// In en, this message translates to:
  /// **'Create New password'**
  String get createNewPassword;

  /// No description provided for @createNewPasswordHint.
  ///
  /// In en, this message translates to:
  /// **'Your new password must be different from previous used passwords.'**
  String get createNewPasswordHint;

  /// No description provided for @resetPassword.
  ///
  /// In en, this message translates to:
  /// **'Reset Password'**
  String get resetPassword;

  /// No description provided for @newPassword.
  ///
  /// In en, this message translates to:
  /// **'New Password'**
  String get newPassword;

  /// No description provided for @passwordChangeSuccess.
  ///
  /// In en, this message translates to:
  /// **'Password Changed Successfully'**
  String get passwordChangeSuccess;

  /// No description provided for @emailRequired.
  ///
  /// In en, this message translates to:
  /// **'Email is required'**
  String get emailRequired;

  /// No description provided for @passwordRequired.
  ///
  /// In en, this message translates to:
  /// **'Password is required'**
  String get passwordRequired;

  /// No description provided for @isRequired.
  ///
  /// In en, this message translates to:
  /// **'This field is required'**
  String get isRequired;

  /// No description provided for @validEmail.
  ///
  /// In en, this message translates to:
  /// **'Please enter valid email address'**
  String get validEmail;

  /// No description provided for @enterAssociatedEmail.
  ///
  /// In en, this message translates to:
  /// **'Enter the email associated with your account and we’ll send an email with instructions to reset your password.'**
  String get enterAssociatedEmail;

  /// Error message for minimum length validation
  ///
  /// In en, this message translates to:
  /// **'This field must be at least {min} characters long'**
  String minLengthValidation(int min);

  /// Error message for maximum length validation
  ///
  /// In en, this message translates to:
  /// **'This field must be at most {max} characters long'**
  String maxLengthValidation(int max);

  /// No description provided for @yourPasswordChanged.
  ///
  /// In en, this message translates to:
  /// **'Your password has been changed successfully.'**
  String get yourPasswordChanged;

  /// No description provided for @confirmPassword.
  ///
  /// In en, this message translates to:
  /// **'Confirm Password'**
  String get confirmPassword;

  /// No description provided for @logout.
  ///
  /// In en, this message translates to:
  /// **'Logout'**
  String get logout;

  /// No description provided for @getStarted.
  ///
  /// In en, this message translates to:
  /// **'Get Started'**
  String get getStarted;

  /// No description provided for @rememberMe.
  ///
  /// In en, this message translates to:
  /// **'Remember me'**
  String get rememberMe;

  /// No description provided for @forgotPassword.
  ///
  /// In en, this message translates to:
  /// **'Forgot password'**
  String get forgotPassword;

  /// No description provided for @backToLogin.
  ///
  /// In en, this message translates to:
  /// **'Back to login'**
  String get backToLogin;

  /// No description provided for @continueAction.
  ///
  /// In en, this message translates to:
  /// **'Continue'**
  String get continueAction;

  /// No description provided for @signUp.
  ///
  /// In en, this message translates to:
  /// **'Sign up'**
  String get signUp;

  /// No description provided for @signIn.
  ///
  /// In en, this message translates to:
  /// **'Sign in'**
  String get signIn;

  /// No description provided for @email.
  ///
  /// In en, this message translates to:
  /// **'Email'**
  String get email;

  /// No description provided for @emailAddress.
  ///
  /// In en, this message translates to:
  /// **'Email Address'**
  String get emailAddress;

  /// No description provided for @password.
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get password;

  /// No description provided for @firstName.
  ///
  /// In en, this message translates to:
  /// **'First Name'**
  String get firstName;

  /// No description provided for @lastName.
  ///
  /// In en, this message translates to:
  /// **'Last Name'**
  String get lastName;

  /// No description provided for @dontHaveAccount.
  ///
  /// In en, this message translates to:
  /// **'Don\'t have an account? '**
  String get dontHaveAccount;

  /// No description provided for @alreadyHaveAccount.
  ///
  /// In en, this message translates to:
  /// **'Already have an account? '**
  String get alreadyHaveAccount;

  /// No description provided for @checkYourMail.
  ///
  /// In en, this message translates to:
  /// **'Check your mail'**
  String get checkYourMail;

  /// No description provided for @enterVerificationCode.
  ///
  /// In en, this message translates to:
  /// **'Please enter 4 digit code sent to your mail hello**@gmail.com.'**
  String get enterVerificationCode;

  /// No description provided for @didntGetCode.
  ///
  /// In en, this message translates to:
  /// **'Didn\'t get a code? '**
  String get didntGetCode;

  /// No description provided for @clickToResend.
  ///
  /// In en, this message translates to:
  /// **'Click to resend'**
  String get clickToResend;

  /// No description provided for @didNotReceiveEmail.
  ///
  /// In en, this message translates to:
  /// **'Did not receive the email? Check your spam filter. or '**
  String get didNotReceiveEmail;

  /// No description provided for @tryAnotherEmail.
  ///
  /// In en, this message translates to:
  /// **'try another email address'**
  String get tryAnotherEmail;

  /// No description provided for @learnFlutterTitle.
  ///
  /// In en, this message translates to:
  /// **'Learn Flutter with comprehensive tutorials.'**
  String get learnFlutterTitle;

  /// No description provided for @learnFlutterSubtitle.
  ///
  /// In en, this message translates to:
  /// **'Step-by-step guides for building Flutter apps.'**
  String get learnFlutterSubtitle;

  /// No description provided for @learnFlutterDescription.
  ///
  /// In en, this message translates to:
  /// **'Get notifications for new tutorials and updates.'**
  String get learnFlutterDescription;

  /// No description provided for @joinCommunityTitle.
  ///
  /// In en, this message translates to:
  /// **'Join the Flutter community.'**
  String get joinCommunityTitle;

  /// No description provided for @joinCommunitySubtitle.
  ///
  /// In en, this message translates to:
  /// **'Connect with other Flutter developers.'**
  String get joinCommunitySubtitle;

  /// No description provided for @joinCommunityDescription.
  ///
  /// In en, this message translates to:
  /// **'Participate in community events and discussions.'**
  String get joinCommunityDescription;

  /// No description provided for @buildDeployTitle.
  ///
  /// In en, this message translates to:
  /// **'Build and deploy Flutter apps easily.'**
  String get buildDeployTitle;

  /// No description provided for @buildDeploySubtitle.
  ///
  /// In en, this message translates to:
  /// **'Access tools and resources for app development.'**
  String get buildDeploySubtitle;

  /// No description provided for @buildDeployDescription.
  ///
  /// In en, this message translates to:
  /// **'Deploy your apps to multiple platforms with ease.'**
  String get buildDeployDescription;

  /// Error message for password minimum length validation
  ///
  /// In en, this message translates to:
  /// **'Password must be at least {minLength} characters'**
  String passwordMinLengthValidation(String minLength);

  /// No description provided for @passwordNumberValidation.
  ///
  /// In en, this message translates to:
  /// **'Password must contain at least one number'**
  String get passwordNumberValidation;

  /// No description provided for @passwordLowerCaseValidation.
  ///
  /// In en, this message translates to:
  /// **'Password must contain at least one lowercase letter'**
  String get passwordLowerCaseValidation;

  /// No description provided for @passwordUpperCaseValidation.
  ///
  /// In en, this message translates to:
  /// **'Password must contain at least one uppercase letter'**
  String get passwordUpperCaseValidation;

  /// No description provided for @passwordSpecialCharValidation.
  ///
  /// In en, this message translates to:
  /// **'Password must contain at least one special character'**
  String get passwordSpecialCharValidation;
}

class _AppLocalizationsDelegate
    extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) =>
      <String>['ar', 'bn', 'en'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {
  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'ar':
      return AppLocalizationsAr();
    case 'bn':
      return AppLocalizationsBn();
    case 'en':
      return AppLocalizationsEn();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.',
  );
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/gen/l10n/app_localizations_ar.dart app_localizations_ar.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Arabic (`ar`).
class AppLocalizationsAr extends AppLocalizations {
  AppLocalizationsAr([String locale = 'ar']) : super(locale);

  @override
  String get english => 'English';

  @override
  String get bangla => 'বাংলা';

  @override
  String get arabic => 'العربية';

  @override
  String get home => 'الرئيسية';

  @override
  String get profile => 'الملف الشخصي';

  @override
  String get login => 'تسجيل الدخول';

  @override
  String get createNewPassword => 'إنشاء كلمة مرور جديدة';

  @override
  String get createNewPasswordHint =>
      'يجب أن تكون كلمة المرور الجديدة مختلفة عن كلمات المرور المستخدمة سابقاً.';

  @override
  String get resetPassword => 'إعادة تعيين كلمة المرور';

  @override
  String get newPassword => 'كلمة المرور الجديدة';

  @override
  String get passwordChangeSuccess => 'تم تغيير كلمة المرور بنجاح';

  @override
  String get emailRequired => 'البريد الإلكتروني مطلوب';

  @override
  String get passwordRequired => 'كلمة المرور مطلوبة';

  @override
  String get isRequired => 'هذا الحقل مطلوب';

  @override
  String get validEmail => 'يرجى إدخال عنوان بريد إلكتروني صحيح';

  @override
  String get enterAssociatedEmail =>
      'أدخل البريد الإلكتروني المرتبط بحسابك وسنرسل لك بريداً إلكترونياً مع تعليمات لإعادة تعيين كلمة المرور.';

  @override
  String minLengthValidation(int min) {
    return 'يجب أن يحتوي هذا الحقل على $min أحرف على الأقل';
  }

  @override
  String maxLengthValidation(int max) {
    return 'يجب أن يحتوي هذا الحقل على $max أحرف كحد أقصى';
  }

  @override
  String get yourPasswordChanged => 'تم تغيير كلمة المرور بنجاح.';

  @override
  String get confirmPassword => 'تأكيد كلمة المرور';

  @override
  String get logout => 'تسجيل الخروج';

  @override
  String get getStarted => 'ابدأ';

  @override
  String get rememberMe => 'تذكرني';

  @override
  String get forgotPassword => 'نسيت كلمة المرور';

  @override
  String get backToLogin => 'العودة إلى تسجيل الدخول';

  @override
  String get continueAction => 'متابعة';

  @override
  String get signUp => 'إنشاء حساب';

  @override
  String get signIn => 'تسجيل الدخول';

  @override
  String get email => 'البريد الإلكتروني';

  @override
  String get emailAddress => 'عنوان البريد الإلكتروني';

  @override
  String get password => 'كلمة المرور';

  @override
  String get firstName => 'الاسم الأول';

  @override
  String get lastName => 'اسم العائلة';

  @override
  String get dontHaveAccount => 'ليس لديك حساب؟ ';

  @override
  String get alreadyHaveAccount => 'لديك حساب بالفعل؟ ';

  @override
  String get checkYourMail => 'تحقق من بريدك الإلكتروني';

  @override
  String get enterVerificationCode =>
      'يرجى إدخال الرمز المكون من 4 أرقام المرسل إلى بريدك الإلكتروني hello**@gmail.com.';

  @override
  String get didntGetCode => 'لم تحصل على رمز؟ ';

  @override
  String get clickToResend => 'انقر لإعادة الإرسال';

  @override
  String get didNotReceiveEmail =>
      'لم تستلم البريد الإلكتروني؟ تحقق من مجلد الرسائل غير المرغوب فيها. أو ';

  @override
  String get tryAnotherEmail => 'جرب عنوان بريد إلكتروني آخر';

  @override
  String get learnFlutterTitle => 'تعلم Flutter مع دروس شاملة.';

  @override
  String get learnFlutterSubtitle => 'دليل خطوة بخطوة لبناء تطبيقات Flutter.';

  @override
  String get learnFlutterDescription =>
      'احصل على إشعارات للدروس الجديدة والتحديثات.';

  @override
  String get joinCommunityTitle => 'انضم إلى مجتمع Flutter.';

  @override
  String get joinCommunitySubtitle => 'تواصل مع مطوري Flutter الآخرين.';

  @override
  String get joinCommunityDescription => 'شارك في أحداث المجتمع والمناقشات.';

  @override
  String get buildDeployTitle => 'ابن ونشر تطبيقات Flutter بسهولة.';

  @override
  String get buildDeploySubtitle => 'احصل على أدوات وموارد لتطوير التطبيقات.';

  @override
  String get buildDeployDescription => 'انشر تطبيقاتك على منصات متعددة بسهولة.';

  @override
  String passwordMinLengthValidation(String minLength) {
    return 'يجب أن تحتوي كلمة المرور على $minLength أحرف على الأقل';
  }

  @override
  String get passwordNumberValidation =>
      'يجب أن تحتوي كلمة المرور على رقم واحد على الأقل';

  @override
  String get passwordLowerCaseValidation =>
      'يجب أن تحتوي كلمة المرور على حرف صغير واحد على الأقل';

  @override
  String get passwordUpperCaseValidation =>
      'يجب أن تحتوي كلمة المرور على حرف كبير واحد على الأقل';

  @override
  String get passwordSpecialCharValidation =>
      'يجب أن تحتوي كلمة المرور على رمز خاص واحد على الأقل';
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/gen/l10n/app_localizations_en.dart app_localizations_en.dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get english => 'English';

  @override
  String get bangla => 'বাংলা';

  @override
  String get arabic => 'العربية';

  @override
  String get home => 'Home';

  @override
  String get profile => 'Profile';

  @override
  String get login => 'Login';

  @override
  String get createNewPassword => 'Create New password';

  @override
  String get createNewPasswordHint =>
      'Your new password must be different from previous used passwords.';

  @override
  String get resetPassword => 'Reset Password';

  @override
  String get newPassword => 'New Password';

  @override
  String get passwordChangeSuccess => 'Password Changed Successfully';

  @override
  String get emailRequired => 'Email is required';

  @override
  String get passwordRequired => 'Password is required';

  @override
  String get isRequired => 'This field is required';

  @override
  String get validEmail => 'Please enter valid email address';

  @override
  String get enterAssociatedEmail =>
      'Enter the email associated with your account and we’ll send an email with instructions to reset your password.';

  @override
  String minLengthValidation(int min) {
    return 'This field must be at least $min characters long';
  }

  @override
  String maxLengthValidation(int max) {
    return 'This field must be at most $max characters long';
  }

  @override
  String get yourPasswordChanged =>
      'Your password has been changed successfully.';

  @override
  String get confirmPassword => 'Confirm Password';

  @override
  String get logout => 'Logout';

  @override
  String get getStarted => 'Get Started';

  @override
  String get rememberMe => 'Remember me';

  @override
  String get forgotPassword => 'Forgot password';

  @override
  String get backToLogin => 'Back to login';

  @override
  String get continueAction => 'Continue';

  @override
  String get signUp => 'Sign up';

  @override
  String get signIn => 'Sign in';

  @override
  String get email => 'Email';

  @override
  String get emailAddress => 'Email Address';

  @override
  String get password => 'Password';

  @override
  String get firstName => 'First Name';

  @override
  String get lastName => 'Last Name';

  @override
  String get dontHaveAccount => 'Don\'t have an account? ';

  @override
  String get alreadyHaveAccount => 'Already have an account? ';

  @override
  String get checkYourMail => 'Check your mail';

  @override
  String get enterVerificationCode =>
      'Please enter 4 digit code sent to your mail hello**@gmail.com.';

  @override
  String get didntGetCode => 'Didn\'t get a code? ';

  @override
  String get clickToResend => 'Click to resend';

  @override
  String get didNotReceiveEmail =>
      'Did not receive the email? Check your spam filter. or ';

  @override
  String get tryAnotherEmail => 'try another email address';

  @override
  String get learnFlutterTitle => 'Learn Flutter with comprehensive tutorials.';

  @override
  String get learnFlutterSubtitle =>
      'Step-by-step guides for building Flutter apps.';

  @override
  String get learnFlutterDescription =>
      'Get notifications for new tutorials and updates.';

  @override
  String get joinCommunityTitle => 'Join the Flutter community.';

  @override
  String get joinCommunitySubtitle => 'Connect with other Flutter developers.';

  @override
  String get joinCommunityDescription =>
      'Participate in community events and discussions.';

  @override
  String get buildDeployTitle => 'Build and deploy Flutter apps easily.';

  @override
  String get buildDeploySubtitle =>
      'Access tools and resources for app development.';

  @override
  String get buildDeployDescription =>
      'Deploy your apps to multiple platforms with ease.';

  @override
  String passwordMinLengthValidation(String minLength) {
    return 'Password must be at least $minLength characters';
  }

  @override
  String get passwordNumberValidation =>
      'Password must contain at least one number';

  @override
  String get passwordLowerCaseValidation =>
      'Password must contain at least one lowercase letter';

  @override
  String get passwordUpperCaseValidation =>
      'Password must contain at least one uppercase letter';

  @override
  String get passwordSpecialCharValidation =>
      'Password must contain at least one special character';
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/utiliity/validation/email_validation.dart email_validation.dart
import 'package:flutter/material.dart';

import '../../extensions/app_localization.dart';
import 'validation.dart';

class EmailValidation extends Validation<String> {
  @override
  String? validate(BuildContext context, String? value) {
    final emailRegex = RegExp(r'^[\w-\.]+(\+[\w-\.]+)?@([\w-]+\.)+[\w-]{2,4}$');

    if (value == null) return null;

    if (!emailRegex.hasMatch(value)) {
      return context.locale.validEmail;
    }

    return null;
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/utiliity/validation/password_validation.dart password_validation.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../extensions/app_localization.dart';
import 'validation.dart';

class PasswordValidation extends Validation<String> {
  PasswordValidation({
    this.minLength = 6,
    this.number = false,
    this.lowerCase = false,
    this.upperCase = false,
    this.specialChar = false,
  });

  final int minLength;
  final bool number;
  final bool lowerCase;
  final bool upperCase;
  final bool specialChar;

  @override
  String? validate(BuildContext context, String? value) {
    if (value == null) return null;

    if (value.length < minLength) {
      final localizedNumber = NumberFormat.decimalPattern(
        Localizations.localeOf(context).languageCode,
      ).format(minLength);

      return context.locale.passwordMinLengthValidation(localizedNumber);
    }

    if (number && !value.contains(RegExp(r'\d'))) {
      return context.locale.passwordNumberValidation;
    }

    if (lowerCase && !value.contains(RegExp(r'[a-z]'))) {
      return context.locale.passwordLowerCaseValidation;
    }

    if (upperCase && !value.contains(RegExp(r'[A-Z]'))) {
      return context.locale.passwordUpperCaseValidation;
    }

    if (specialChar && !value.contains(RegExp(r'[!@#$%^&*(),.?":{}|<>]'))) {
      return context.locale.passwordSpecialCharValidation;
    }

    return null;
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/utiliity/validation/validation.dart validation.dart
import 'package:flutter/material.dart';

export 'email_validation.dart';
export 'length_validation.dart';
export 'password_validation.dart';
export 'required_validation.dart';
export 'validation_impl.dart';

abstract class Validation<T> {
  const Validation();

  String? validate(BuildContext context, T? value);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/utiliity/validation/length_validation.dart length_validation.dart
import 'package:flutter/material.dart';

import '../../extensions/app_localization.dart';
import 'validation.dart';

class LengthValidation<T> extends Validation<T> {
  LengthValidation({required this.min, required this.max});

  final int min;
  final int max;

  @override
  String? validate(BuildContext context, T? value) {
    if (value == null) return null;

    if (value is String && (value as String).length < min) {
      return context.locale.minLengthValidation(min);
    }

    if (value is String && (value as String).length > max) {
      return context.locale.maxLengthValidation(max);
    }

    return null;
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/utiliity/validation/validation_impl.dart validation_impl.dart
import 'package:flutter/material.dart';

import 'validation.dart';

class Validator {
  Validator(this.context);

  final BuildContext context;

  FormFieldValidator<T> apply<T>(List<Validation<T>> validations) {
    return (T? value) {
      for (Validation validation in validations) {
        final error = validation.validate(context, value);
        if (error != null) return error;
      }

      return null;
    };
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/core/utiliity/validation/required_validation.dart required_validation.dart
import 'package:flutter/material.dart';

import '../../extensions/app_localization.dart';
import 'validation.dart';

class RequiredValidation<T> extends Validation<T> {
  @override
  String? validate(BuildContext context, T? value) {
    if (value == null) {
      return context.locale.isRequired;
    }

    if (value is String && (value as String).isEmpty) {
      return context.locale.isRequired;
    }

    return null;
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/models/sign_up_model.dart sign_up_model.dart
import '../../domain/entities/sign_up_entity.dart';

extension SignUpRequestModel on SignUpRequestEntity {
  Map<String, dynamic> toJson() {
    return {
      'first_name': firstName,
      'last_name': lastName,
      'email': email,
      'password': password,
    };
  }
}

class SignUpResponseModel extends SignUpResponseEntity {
  SignUpResponseModel({required super.accessToken});

  factory SignUpResponseModel.fromJson(Map<String, dynamic> json) {
    return SignUpResponseModel(accessToken: json['access_token']);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/models/login_model.mapper.dart login_model.mapper.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, unnecessary_cast, override_on_non_overriding_member
// ignore_for_file: strict_raw_type, inference_failure_on_untyped_parameter

part of 'login_model.dart';

class LoginResponseModelMapper extends ClassMapperBase<LoginResponseModel> {
  LoginResponseModelMapper._();

  static LoginResponseModelMapper? _instance;
  static LoginResponseModelMapper ensureInitialized() {
    if (_instance == null) {
      MapperContainer.globals.use(_instance = LoginResponseModelMapper._());
    }
    return _instance!;
  }

  @override
  final String id = 'LoginResponseModel';

  static int _$id(LoginResponseModel v) => v.id;
  static const Field<LoginResponseModel, int> _f$id = Field('id', _$id);
  static String _$username(LoginResponseModel v) => v.username;
  static const Field<LoginResponseModel, String> _f$username =
      Field('username', _$username);
  static String _$email(LoginResponseModel v) => v.email;
  static const Field<LoginResponseModel, String> _f$email =
      Field('email', _$email);
  static String _$firstName(LoginResponseModel v) => v.firstName;
  static const Field<LoginResponseModel, String> _f$firstName =
      Field('firstName', _$firstName);
  static String _$lastName(LoginResponseModel v) => v.lastName;
  static const Field<LoginResponseModel, String> _f$lastName =
      Field('lastName', _$lastName);
  static String _$image(LoginResponseModel v) => v.image;
  static const Field<LoginResponseModel, String> _f$image =
      Field('image', _$image);
  static String _$accessToken(LoginResponseModel v) => v.accessToken;
  static const Field<LoginResponseModel, String> _f$accessToken =
      Field('accessToken', _$accessToken);
  static String _$gender(LoginResponseModel v) => v.gender;
  static const Field<LoginResponseModel, String> _f$gender =
      Field('gender', _$gender);
  static String _$refreshToken(LoginResponseModel v) => v.refreshToken;
  static const Field<LoginResponseModel, String> _f$refreshToken =
      Field('refreshToken', _$refreshToken);

  @override
  final MappableFields<LoginResponseModel> fields = const {
    #id: _f$id,
    #username: _f$username,
    #email: _f$email,
    #firstName: _f$firstName,
    #lastName: _f$lastName,
    #image: _f$image,
    #accessToken: _f$accessToken,
    #gender: _f$gender,
    #refreshToken: _f$refreshToken,
  };

  static LoginResponseModel _instantiate(DecodingData data) {
    return LoginResponseModel(
        id: data.dec(_f$id),
        username: data.dec(_f$username),
        email: data.dec(_f$email),
        firstName: data.dec(_f$firstName),
        lastName: data.dec(_f$lastName),
        image: data.dec(_f$image),
        accessToken: data.dec(_f$accessToken),
        gender: data.dec(_f$gender),
        refreshToken: data.dec(_f$refreshToken));
  }

  @override
  final Function instantiate = _instantiate;

  static LoginResponseModel fromJson(Map<String, dynamic> map) {
    return ensureInitialized().decodeMap<LoginResponseModel>(map);
  }

  static LoginResponseModel fromJsonString(String json) {
    return ensureInitialized().decodeJson<LoginResponseModel>(json);
  }
}

mixin LoginResponseModelMappable {}

class LoginRequestModelMapper extends ClassMapperBase<LoginRequestModel> {
  LoginRequestModelMapper._();

  static LoginRequestModelMapper? _instance;
  static LoginRequestModelMapper ensureInitialized() {
    if (_instance == null) {
      MapperContainer.globals.use(_instance = LoginRequestModelMapper._());
    }
    return _instance!;
  }

  @override
  final String id = 'LoginRequestModel';

  static String _$username(LoginRequestModel v) => v.username;
  static const Field<LoginRequestModel, String> _f$username =
      Field('username', _$username);
  static String _$password(LoginRequestModel v) => v.password;
  static const Field<LoginRequestModel, String> _f$password =
      Field('password', _$password);

  @override
  final MappableFields<LoginRequestModel> fields = const {
    #username: _f$username,
    #password: _f$password,
  };

  static LoginRequestModel _instantiate(DecodingData data) {
    return LoginRequestModel(
        username: data.dec(_f$username), password: data.dec(_f$password));
  }

  @override
  final Function instantiate = _instantiate;
}

mixin LoginRequestModelMappable {
  String toJsonString() {
    return LoginRequestModelMapper.ensureInitialized()
        .encodeJson<LoginRequestModel>(this as LoginRequestModel);
  }

  Map<String, dynamic> toJson() {
    return LoginRequestModelMapper.ensureInitialized()
        .encodeMap<LoginRequestModel>(this as LoginRequestModel);
  }

  LoginRequestModelCopyWith<LoginRequestModel, LoginRequestModel,
          LoginRequestModel>
      get copyWith =>
          _LoginRequestModelCopyWithImpl<LoginRequestModel, LoginRequestModel>(
              this as LoginRequestModel, $identity, $identity);
}

extension LoginRequestModelValueCopy<$R, $Out>
    on ObjectCopyWith<$R, LoginRequestModel, $Out> {
  LoginRequestModelCopyWith<$R, LoginRequestModel, $Out>
      get $asLoginRequestModel => $base
          .as((v, t, t2) => _LoginRequestModelCopyWithImpl<$R, $Out>(v, t, t2));
}

abstract class LoginRequestModelCopyWith<$R, $In extends LoginRequestModel,
    $Out> implements ClassCopyWith<$R, $In, $Out> {
  $R call({String? username, String? password});
  LoginRequestModelCopyWith<$R2, $In, $Out2> $chain<$R2, $Out2>(
      Then<$Out2, $R2> t);
}

class _LoginRequestModelCopyWithImpl<$R, $Out>
    extends ClassCopyWithBase<$R, LoginRequestModel, $Out>
    implements LoginRequestModelCopyWith<$R, LoginRequestModel, $Out> {
  _LoginRequestModelCopyWithImpl(super.value, super.then, super.then2);

  @override
  late final ClassMapperBase<LoginRequestModel> $mapper =
      LoginRequestModelMapper.ensureInitialized();
  @override
  $R call({String? username, String? password}) => $apply(FieldCopyWithData({
        if (username != null) #username: username,
        if (password != null) #password: password
      }));
  @override
  LoginRequestModel $make(CopyWithData data) => LoginRequestModel(
      username: data.get(#username, or: $value.username),
      password: data.get(#password, or: $value.password));

  @override
  LoginRequestModelCopyWith<$R2, LoginRequestModel, $Out2> $chain<$R2, $Out2>(
          Then<$Out2, $R2> t) =>
      _LoginRequestModelCopyWithImpl<$R2, $Out2>($value, $cast, t);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/models/login_model.dart login_model.dart
import 'package:dart_mappable/dart_mappable.dart';

import '../../domain/entities/login_entity.dart';

part 'login_model.mapper.dart';

@MappableClass(generateMethods: GenerateMethods.decode)
class LoginResponseModel extends LoginResponseEntity
    with LoginResponseModelMappable {
  LoginResponseModel({
    required this.id,
    required this.username,
    required this.email,
    required this.firstName,
    required this.lastName,
    required this.image,
    required super.accessToken,
    required this.gender,
    required this.refreshToken,
  });

  final int id;
  final String username;
  final String email;
  final String firstName;
  final String lastName;
  final String gender;
  final String image;
  final String refreshToken;

  static const fromJson = LoginResponseModelMapper.fromJson;
}

@MappableClass(generateMethods: GenerateMethods.copy | GenerateMethods.encode)
class LoginRequestModel extends LoginRequestEntity
    with LoginRequestModelMappable {
  LoginRequestModel({required super.username, required super.password});

  factory LoginRequestModel.fromEntity(LoginRequestEntity entity) {
    return LoginRequestModel(
      username: entity.username,
      password: entity.password,
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/models/task_extensions.dart task_extensions.dart
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/entities/repeat_rule.dart';

extension TaskRepeatRule on Task {
  RepeatRule? get repeatRule {
    if (repeatType == RepeatType.none) return null;
    if (repeatParams == null) return null;
    try {
      return RepeatRule.fromJson(repeatParams!, repeatType.index);
    } catch (e) {
      // ignore
      return null;
    }
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/services/cache/cache_service.dart cache_service.dart
import 'package:shared_preferences/shared_preferences.dart';

part 'shared_preference_service.dart';

enum CacheKey {
  accessToken,
  refreshToken,
  isOnBoardingCompleted,
  isLoggedIn,
  rememberMe,
  language,
}

abstract class CacheService {
  Future<void> save<T>(CacheKey key, T value);

  T? get<T>(CacheKey key);

  Future<void> remove(List<CacheKey> keys);

  Future<void> clear();
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/services/cache/shared_preference_service.dart shared_preference_service.dart
part of 'cache_service.dart';

class SharedPreferencesService implements CacheService {
  SharedPreferencesService(this.prefs);

  final SharedPreferences prefs;

  @override
  Future<void> save<T>(CacheKey key, T value) async {
    switch (T) {
      case const (String):
        await prefs.setString(key.name, value as String);
        break;
      case const (int):
        await prefs.setInt(key.name, value as int);
        break;
      case const (bool):
        await prefs.setBool(key.name, value as bool);
        break;
      case const (double):
        await prefs.setDouble(key.name, value as double);
        break;
      default:
        await prefs.setString(key.name, value as String);
    }
  }

  @override
  T? get<T>(CacheKey key) {
    return switch (T) {
      const (String) => prefs.getString(key.name) as T?,
      const (int) => prefs.getInt(key.name) as T?,
      const (bool) => prefs.getBool(key.name) as T?,
      const (double) => prefs.getDouble(key.name) as T?,
      _ => prefs.get(key.name) as T?,
    };
  }

  @override
  Future<void> remove(List<CacheKey> keys) async {
    for (final key in keys) {
      await prefs.remove(key.name);
    }
  }

  @override
  Future<void> clear() async {
    await prefs.clear();
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/repositories/session_repository_impl.dart session_repository_impl.dart
import 'package:drift/drift.dart';
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/entities/conflict_resolution.dart';
import 'package:tempo/src/domain/repositories/session_repository.dart';
import 'package:uuid/uuid.dart';

class SessionRepositoryImpl implements SessionRepository {
  final AppDatabase _db;
  final Uuid _uuid = const Uuid();

  SessionRepositoryImpl(this._db);

  @override
  Stream<Session?> watchActiveSession() {
    return _db.watchActiveSession();
  }

  @override
  Stream<List<SessionWithActivityType>> watchSessionsForPeriod({
    required DateTime from,
    required DateTime to,
  }) {
    return _db.watchSessionsForPeriod(from: from, to: to);
  }

  @override
  Future<List<Session>> getSessionsForDay(DateTime day) {
    return _db.getSessionsForDay(day);
  }

  @override
  Future<void> createSession({
    required String activityTypeId,
    required DateTime startAt,
    DateTime? endAt,
    String? note,
  }) async {
    final session = SessionsCompanion(
      id: Value(_uuid.v4()),
      activityTypeId: Value(activityTypeId),
      startAt: Value(startAt),
      endAt: Value(endAt),
      note: Value(note),
    );

    await _db.createSession(session);
  }

  @override
  Future<void> updateSession(Session session) {
    return _db.updateSession(session);
  }

  @override
  Future<void> deleteSession(String id) {
    return _db.deleteSession(id);
  }

  @override
  Future<void> startSession(String activityTypeId) async {
    // Закрыть активную сессию если есть
    await stopActiveSession();

    // Создать новую сессию
    await createSession(
      activityTypeId: activityTypeId,
      startAt: DateTime.now(),
    );
  }

  @override
  Future<void> stopActiveSession() async {
    await _db.stopActiveSession(DateTime.now());
  }

  @override
  Future<void> switchSession(String newActivityTypeId) async {
    final now = DateTime.now();
    
    // Закрыть текущую сессию
    await _db.stopActiveSession(now);
    
    // Сразу открыть новую
    await createSession(
      activityTypeId: newActivityTypeId,
      startAt: now,
    );
  }

  @override
  Future<List<SessionConflict>> detectConflicts({
    required DateTime candidateStart,
    required DateTime candidateEnd,
    required String candidateActivityName,
    String? excludeSessionId,
  }) async {
    final conflictingSessions = await _db.detectConflicts(
      candidateStart: candidateStart,
      candidateEnd: candidateEnd,
      excludeSessionId: excludeSessionId,
    );

    // Получить ActivityType для каждой конфликтующей сессии
    final conflicts = <SessionConflict>[];
    
    for (final session in conflictingSessions) {
      // Query activity type для получения имени
      final query = _db.select(_db.activityTypes)
        ..where((a) => a.id.equals(session.activityTypeId));
      final activityType = await query.getSingleOrNull();
      
      if (activityType != null) {
        conflicts.add(SessionConflict(
          existingSessionId: session.id,
          existingActivityName: activityType.name,
          existingStart: session.startAt,
          existingEnd: session.endAt,
          candidateStart: candidateStart,
          candidateEnd: candidateEnd,
          candidateActivityName: candidateActivityName,
        ));
      }
    }

    return conflicts;
  }

  @override
  Future<void> resolveConflict({
    required SessionConflict conflict,
    required ConflictResolutionStrategy strategy,
    required String newActivityTypeId,
    DateTime? newStartAt,
    DateTime? newEndAt,
    String? note,
  }) async {
    switch (strategy) {
      case ConflictResolutionStrategy.trimPrevious:
        // Обрезать существующую сессию - установить endAt = candidateStart
        final query = _db.select(_db.sessions)
          ..where((s) => s.id.equals(conflict.existingSessionId));
        final existingSession = await query.getSingle();
        
        await _db.updateSession(
          existingSession.copyWith(endAt: Value(conflict.candidateStart)),
        );
        
        // Создать новую сессию
        await createSession(
          activityTypeId: newActivityTypeId,
          startAt: newStartAt ?? conflict.candidateStart,
          endAt: newEndAt,
          note: note,
        );
        break;

      case ConflictResolutionStrategy.trimNew:
        // Обрезать новую сессию - начать после окончания существующей
        final trimmedStart = conflict.existingEnd ?? DateTime.now();
        if (trimmedStart.isBefore(newEndAt ?? conflict.candidateEnd)) {
          await createSession(
            activityTypeId: newActivityTypeId,
            startAt: trimmedStart,
            endAt: newEndAt,
            note: note,
          );
        }
        break;

      case ConflictResolutionStrategy.splitPrevious:
        // Разрезать существующую сессию на две части
        final query = _db.select(_db.sessions)
          ..where((s) => s.id.equals(conflict.existingSessionId));
        final existingSession = await query.getSingle();
        
        // Первая часть: от оригинального start до candidateStart
        await _db.updateSession(
          existingSession.copyWith(endAt: Value(conflict.candidateStart)),
        );
        
        // Вторая часть: от candidateEnd до оригинального end
        if (conflict.existingEnd != null && 
            conflict.candidateEnd.isBefore(conflict.existingEnd!)) {
          await createSession(
            activityTypeId: existingSession.activityTypeId,
            startAt: conflict.candidateEnd,
            endAt: conflict.existingEnd,
            note: existingSession.note,
          );
        }
        
        // Создать новую сессию посередине
        await createSession(
          activityTypeId: newActivityTypeId,
          startAt: newStartAt ?? conflict.candidateStart,
          endAt: newEndAt ?? conflict.candidateEnd,
          note: note,
        );
        break;

      case ConflictResolutionStrategy.cancel:
        // Ничего не делать
        break;
    }
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/repositories/authentication_repository_impl.dart authentication_repository_impl.dart
import '../../core/base/failure.dart';
import '../../core/base/result.dart';
import '../../domain/entities/login_entity.dart';
import '../../domain/entities/sign_up_entity.dart';
import '../../domain/repositories/authentication_repository.dart';
import '../models/login_model.dart';
import '../services/cache/cache_service.dart';
import '../services/network/rest_client.dart';

final class AuthenticationRepositoryImpl extends AuthenticationRepository {
  AuthenticationRepositoryImpl({required this.remote, required this.local});

  final RestClient remote;
  final CacheService local;

  @override
  Future<SignUpResponseEntity> register(SignUpRequestEntity data) async {
    // TODO: implement resetPassword
    throw UnimplementedError();
  }

  @override
  Future<Result<LoginResponseEntity, Failure>> login(
    LoginRequestEntity data,
  ) async {
    return asyncGuard(() async {
      final model = LoginRequestModel.fromEntity(data);
      final response = await remote.login(model.toJson());

      // Save the session if the user has selected the "Remember Me" option
      if (data.shouldRemeber ?? false) await _saveSession();

      return LoginResponseModel.fromJson(response.data);
    });
  }

  Future<void> _saveSession() async {
    await local.save(CacheKey.isLoggedIn, true);
  }

  /// Manages the "Remember Me" functionality.
  ///
  /// When [rememberMe] is null, retrieves the current setting from cache.
  /// When [rememberMe] has a value, updates the setting in cache.
  /// Returns the current or newly saved value, defaulting to false on errors.
  @override
  Future<bool> rememberMe({bool? rememberMe}) async {
    try {
      if (rememberMe == null) {
        return local.get<bool>(CacheKey.rememberMe) ?? false;
      }

      await local.save(CacheKey.rememberMe, rememberMe);

      return rememberMe;
    } catch (e) {
      return false;
    }
  }

  @override
  Future<String> forgotPassword(Map<String, dynamic> data) {
    // TODO: implement forgotPassword
    throw UnimplementedError();
  }

  @override
  Future<String> resetPassword(Map<String, dynamic> data) {
    // TODO: implement resetPassword
    throw UnimplementedError();
  }

  @override
  Future<String> verifyOTP(Map<String, dynamic> data) {
    // TODO: implement verifyOTP
    throw UnimplementedError();
  }

  @override
  Future<String> resendOTP(Map<String, dynamic> data) {
    // TODO: implement resendOTP
    throw UnimplementedError();
  }

  @override
  Future<void> logout() async {
    await local.remove([CacheKey.isLoggedIn, CacheKey.rememberMe]);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/repositories/router_repository_impl.dart router_repository_impl.dart
import '../../domain/repositories/router_repository.dart';
import '../services/cache/cache_service.dart';

class RouterRepositoryImpl extends RouterRepository {
  RouterRepositoryImpl({required this.cacheService});

  final CacheService cacheService;

  @override
  bool isOnboardingCompleted() {
    return cacheService.get(CacheKey.isOnBoardingCompleted) ?? false;
  }

  @override
  bool isUserLoggedIn() {
    return cacheService.get(CacheKey.isLoggedIn) ?? false;
  }

  @override
  void saveOnboardingAsCompleted() {
    cacheService.save(CacheKey.isOnBoardingCompleted, true);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/repositories/locale_repository_impl.dart locale_repository_impl.dart
import '../../domain/repositories/locale_repository.dart';
import '../services/cache/cache_service.dart';

class LocaleRepositoryImpl extends LocaleRepository {
  LocaleRepositoryImpl(this.local);

  final CacheService local;

  @override
  Future<void> setLanguage(String language) async {
    await local.save(CacheKey.language, language);
  }

  @override
  Future<String> getLanguage() async {
    return local.get<String>(CacheKey.language) ?? 'en';
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/repositories/task_repository_impl.dart task_repository_impl.dart
import 'package:drift/drift.dart';
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/entities/repeat_rule.dart';
import 'package:tempo/src/domain/repositories/task_repository.dart';
import 'package:uuid/uuid.dart';

class TaskRepositoryImpl implements TaskRepository {
  final AppDatabase _db;
  final Uuid _uuid = const Uuid();

  TaskRepositoryImpl(this._db);

  @override
  Stream<List<Task>> watchTasksByStatus(TaskStatus? status) {
    return _db.watchTasksByStatus(status);
  }

  @override
  Future<List<Task>> getOverdueTasks() {
    return _db.getOverdueTasks();
  }

  @override
  Future<List<Task>> getTasksForDate(DateTime date) async {
    // Задачи с deadline на указанную дату или активные
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));
    
    final query = _db.select(_db.tasks)
      ..where((t) => 
          (t.status.equalsValue(TaskStatus.active)) &
          ((t.deadline.isBiggerOrEqualValue(startOfDay) & 
            t.deadline.isSmallerThanValue(endOfDay)) |
           t.deadline.isNull())
      );
    
    return query.get();
  }

  @override
  Future<void> createTask({
    required String title,
    TaskStatus status = TaskStatus.active,
    DateTime? deadline,
    RepeatRule? repeatRule,
  }) async {
    final task = TasksCompanion(
      id: Value(_uuid.v4()),
      title: Value(title),
      status: Value(status),
      deadline: Value(deadline),
      repeatType: Value(_getRepeatType(repeatRule)),
      repeatParams: Value(repeatRule?.toJson()),
      createdAt: Value(DateTime.now()),
    );

    await _db.createTask(task);
  }

  @override
  Future<void> updateTask(Task task, {RepeatRule? repeatRule}) async {
    if (repeatRule != null) {
      final updatedTask = task.copyWith(
        repeatType: _getRepeatType(repeatRule),
        repeatParams: Value(repeatRule.toJson()),
      );
      await _db.updateTask(updatedTask);
    } else {
      await _db.updateTask(task);
    }
  }

  @override
  Future<void> completeTask(String taskId) async {
    final query = _db.select(_db.tasks)..where((t) => t.id.equals(taskId));
    final task = await query.getSingle();
    
    // Сохранить выполнение в истории
    await _db.into(_db.taskCompletions).insert(
      TaskCompletionsCompanion(
        taskId: Value(taskId),
        completedAt: Value(DateTime.now()),
      ),
    );

    // Если задача повторяющаяся - создать следующий экземпляр
    if (task.repeatType != RepeatType.none && task.repeatParams != null) {
      await _generateNextTask(task);
    }
    
    // Обновить статус на done
    await _db.updateTask(task.copyWith(status: TaskStatus.done));
  }

  @override
  Future<void> snoozeTask(String taskId, DateTime until) async {
    final query = _db.select(_db.tasks)..where((t) => t.id.equals(taskId));
    final task = await query.getSingle();
    
    await _db.updateTask(task.copyWith(snoozeUntil: Value(until)));
  }

  @override
  Future<void> rescheduleTask(String taskId, DateTime newDeadline) async {
    final query = _db.select(_db.tasks)..where((t) => t.id.equals(taskId));
    final task = await query.getSingle();
    
    await _db.updateTask(task.copyWith(deadline: Value(newDeadline)));
  }

  @override
  Future<void> deleteTask(String taskId) {
    return _db.deleteTask(taskId);
  }

  @override
  Future<void> archiveTask(String taskId) async {
    final query = _db.select(_db.tasks)..where((t) => t.id.equals(taskId));
    final task = await query.getSingle();
    
    await _db.updateTask(task.copyWith(status: TaskStatus.archived));
  }

  @override
  Future<int> getCompletionCount(String taskId, DateTime from, DateTime to) async {
    final query = _db.select(_db.taskCompletions)
      ..where((tc) => 
          tc.taskId.equals(taskId) &
          tc.completedAt.isBiggerOrEqualValue(from) &
          tc.completedAt.isSmallerThanValue(to)
      );
    
    final completions = await query.get();
    return completions.length;
  }

  @override
  Future<RepeatRule?> getRepeatRule(String taskId) async {
    final query = _db.select(_db.tasks)..where((t) => t.id.equals(taskId));
    final task = await query.getSingle();
    
    if (task.repeatType == RepeatType.none || task.repeatParams == null) {
      return null;
    }
    
    return RepeatRule.fromJson(
      task.repeatParams!,
      task.repeatType.index,
    );
  }

  // ============================================================
  // Private helpers
  // ============================================================

  RepeatType _getRepeatType(RepeatRule? rule) {
    if (rule == null) return RepeatType.none;
    
    return switch (rule) {
      FixedScheduleRepeat() => RepeatType.fixedSchedule,
      XTimesInNDaysRepeat() => RepeatType.xTimesInNDays,
      EveryNDaysAfterCompletionRepeat() => RepeatType.everyNDaysAfterCompletion,
    };
  }

  Future<void> _generateNextTask(Task completedTask) async {
    final repeatRule = await getRepeatRule(completedTask.id);
    if (repeatRule == null) return;

    DateTime? nextDeadline;
    final now = DateTime.now();

    switch (repeatRule) {
      case FixedScheduleRepeat(:final weekdays):
        // Найти следующий день недели из списка
        DateTime candidate = now.add(const Duration(days: 1));
        while (!weekdays.contains(candidate.weekday)) {
          candidate = candidate.add(const Duration(days: 1));
        }
        nextDeadline = candidate;
        break;

      case XTimesInNDaysRepeat(:final times, :final days):
        // Для X раз за N дней - просто создаем задачу без deadline
        // Логика подсчета будет в UI через getCompletionCount
        nextDeadline = null;
        break;

      case EveryNDaysAfterCompletionRepeat(:final days):
        nextDeadline = now.add(Duration(days: days));
        break;
    }

    // Создать новую задачу с тем же title и repeatRule
    await createTask(
      title: completedTask.title,
      deadline: nextDeadline,
      repeatRule: repeatRule,
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/repositories/activity_type_repository_impl.dart activity_type_repository_impl.dart
import 'package:drift/drift.dart';
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/domain/repositories/activity_type_repository.dart';
import 'package:uuid/uuid.dart';

class ActivityTypeRepositoryImpl implements ActivityTypeRepository {
  final AppDatabase _db;
  final Uuid _uuid = const Uuid();

  ActivityTypeRepositoryImpl(this._db);

  @override
  Stream<List<ActivityType>> watchActivityTypes() {
    return _db.watchActivityTypes();
  }

  @override
  Future<void> createActivityType({
    required String name,
    required String color,
    required int order,
    bool isHidden = false,
  }) async {
    final activityType = ActivityTypesCompanion(
      id: Value(_uuid.v4()),
      name: Value(name),
      color: Value(color),
      order: Value(order),
      isHidden: Value(isHidden),
    );

    await _db.createActivityType(activityType);
  }

  @override
  Future<void> updateActivityType(ActivityType activityType) {
    return _db.updateActivityType(activityType);
  }

  @override
  Future<void> deleteActivityType(String id) async {
    final inUse = await isActivityTypeInUse(id);
    if (inUse) {
      throw Exception('Cannot delete activity type that is used in sessions');
    }
    await _db.deleteActivityType(id);
  }

  @override
  Future<bool> isActivityTypeInUse(String id) async {
    final query = _db.select(_db.sessions)
      ..where((s) => s.activityTypeId.equals(id))
      ..limit(1);
    
    final session = await query.getSingleOrNull();
    return session != null;
  }

  @override
  Future<int> getNextOrder() async {
    final query = _db.selectOnly(_db.activityTypes)
      ..addColumns([_db.activityTypes.order.max()]);
    
    final result = await query.getSingleOrNull();
    final maxOrder = result?.read(_db.activityTypes.order.max());
    
    return (maxOrder ?? -1) + 1;
  }

  @override
  Future<void> reorderActivityTypes(List<String> orderedIds) async {
    for (var i = 0; i < orderedIds.length; i++) {
      final query = _db.select(_db.activityTypes)
        ..where((a) => a.id.equals(orderedIds[i]));
      final activityType = await query.getSingleOrNull();
      
      if (activityType != null) {
        await _db.updateActivityType(
          activityType.copyWith(order: i),
        );
      }
    }
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/database/database_seeder.dart database_seeder.dart
import 'package:drift/drift.dart';
import 'package:tempo/src/data/database/drift_database.dart';

/// Хелпер для инициализации дефолтных типов активности
class DatabaseSeeder {
  final AppDatabase _db;

  DatabaseSeeder(this._db);

  /// Заполнить БД начальными данными если она пустая
  Future<void> seedIfEmpty() async {
    final existingTypes = await _db.select(_db.activityTypes).get();
    
    if (existingTypes.isNotEmpty) {
      return; // Уже есть данные
    }

    // Создать дефолтные типы активности
    final defaultTypes = [
      _activityType('Code', '#6366F1', 0),
      _activityType('Study', '#8B5CF6', 1),
      _activityType('Gym', '#EF4444', 2),
      _activityType('Sleep', '#3B82F6', 3),
      _activityType('Meeting', '#F59E0B', 4),
      _activityType('Design', '#EC4899', 5),
      _activityType('Reading', '#10B981', 6),
      _activityType('Break', '#94A3B8', 7),
    ];

    for (final type in defaultTypes) {
      await _db.into(_db.activityTypes).insert(type);
    }
  }

  ActivityTypesCompanion _activityType(String name, String color, int order) {
    return ActivityTypesCompanion(
      id: Value(_generateId(name)),
      name: Value(name),
      color: Value(color),
      order: Value(order),
      isHidden: const Value(false),
    );
  }

  String _generateId(String name) {
    return name.toLowerCase().replaceAll(' ', '_');
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/database/drift_database.g.dart drift_database.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'drift_database.dart';

// ignore_for_file: type=lint
class $ActivityTypesTable extends ActivityTypes
    with TableInfo<$ActivityTypesTable, ActivityType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivityTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _colorMeta = const VerificationMeta('color');
  @override
  late final GeneratedColumn<String> color = GeneratedColumn<String>(
    'color',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _orderMeta = const VerificationMeta('order');
  @override
  late final GeneratedColumn<int> order = GeneratedColumn<int>(
    'order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isHiddenMeta = const VerificationMeta(
    'isHidden',
  );
  @override
  late final GeneratedColumn<bool> isHidden = GeneratedColumn<bool>(
    'is_hidden',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_hidden" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [id, name, color, order, isHidden];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activity_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityType> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('color')) {
      context.handle(
        _colorMeta,
        color.isAcceptableOrUnknown(data['color']!, _colorMeta),
      );
    } else if (isInserting) {
      context.missing(_colorMeta);
    }
    if (data.containsKey('order')) {
      context.handle(
        _orderMeta,
        order.isAcceptableOrUnknown(data['order']!, _orderMeta),
      );
    } else if (isInserting) {
      context.missing(_orderMeta);
    }
    if (data.containsKey('is_hidden')) {
      context.handle(
        _isHiddenMeta,
        isHidden.isAcceptableOrUnknown(data['is_hidden']!, _isHiddenMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityType(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      color: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color'],
      )!,
      order: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}order'],
      )!,
      isHidden: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_hidden'],
      )!,
    );
  }

  @override
  $ActivityTypesTable createAlias(String alias) {
    return $ActivityTypesTable(attachedDatabase, alias);
  }
}

class ActivityType extends DataClass implements Insertable<ActivityType> {
  final String id;
  final String name;

  /// Цвет в формате #RRGGBB
  final String color;

  /// Порядок отображения в UI
  final int order;

  /// Скрыть из календаря
  final bool isHidden;
  const ActivityType({
    required this.id,
    required this.name,
    required this.color,
    required this.order,
    required this.isHidden,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['color'] = Variable<String>(color);
    map['order'] = Variable<int>(order);
    map['is_hidden'] = Variable<bool>(isHidden);
    return map;
  }

  ActivityTypesCompanion toCompanion(bool nullToAbsent) {
    return ActivityTypesCompanion(
      id: Value(id),
      name: Value(name),
      color: Value(color),
      order: Value(order),
      isHidden: Value(isHidden),
    );
  }

  factory ActivityType.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityType(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      color: serializer.fromJson<String>(json['color']),
      order: serializer.fromJson<int>(json['order']),
      isHidden: serializer.fromJson<bool>(json['isHidden']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'color': serializer.toJson<String>(color),
      'order': serializer.toJson<int>(order),
      'isHidden': serializer.toJson<bool>(isHidden),
    };
  }

  ActivityType copyWith({
    String? id,
    String? name,
    String? color,
    int? order,
    bool? isHidden,
  }) => ActivityType(
    id: id ?? this.id,
    name: name ?? this.name,
    color: color ?? this.color,
    order: order ?? this.order,
    isHidden: isHidden ?? this.isHidden,
  );
  ActivityType copyWithCompanion(ActivityTypesCompanion data) {
    return ActivityType(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      color: data.color.present ? data.color.value : this.color,
      order: data.order.present ? data.order.value : this.order,
      isHidden: data.isHidden.present ? data.isHidden.value : this.isHidden,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityType(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('color: $color, ')
          ..write('order: $order, ')
          ..write('isHidden: $isHidden')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, color, order, isHidden);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityType &&
          other.id == this.id &&
          other.name == this.name &&
          other.color == this.color &&
          other.order == this.order &&
          other.isHidden == this.isHidden);
}

class ActivityTypesCompanion extends UpdateCompanion<ActivityType> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> color;
  final Value<int> order;
  final Value<bool> isHidden;
  final Value<int> rowid;
  const ActivityTypesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.color = const Value.absent(),
    this.order = const Value.absent(),
    this.isHidden = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivityTypesCompanion.insert({
    required String id,
    required String name,
    required String color,
    required int order,
    this.isHidden = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       color = Value(color),
       order = Value(order);
  static Insertable<ActivityType> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? color,
    Expression<int>? order,
    Expression<bool>? isHidden,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (color != null) 'color': color,
      if (order != null) 'order': order,
      if (isHidden != null) 'is_hidden': isHidden,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivityTypesCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? color,
    Value<int>? order,
    Value<bool>? isHidden,
    Value<int>? rowid,
  }) {
    return ActivityTypesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      color: color ?? this.color,
      order: order ?? this.order,
      isHidden: isHidden ?? this.isHidden,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (color.present) {
      map['color'] = Variable<String>(color.value);
    }
    if (order.present) {
      map['order'] = Variable<int>(order.value);
    }
    if (isHidden.present) {
      map['is_hidden'] = Variable<bool>(isHidden.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivityTypesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('color: $color, ')
          ..write('order: $order, ')
          ..write('isHidden: $isHidden, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SessionsTable extends Sessions with TableInfo<$SessionsTable, Session> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SessionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _activityTypeIdMeta = const VerificationMeta(
    'activityTypeId',
  );
  @override
  late final GeneratedColumn<String> activityTypeId = GeneratedColumn<String>(
    'activity_type_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES activity_types (id)',
    ),
  );
  static const VerificationMeta _startAtMeta = const VerificationMeta(
    'startAt',
  );
  @override
  late final GeneratedColumn<DateTime> startAt = GeneratedColumn<DateTime>(
    'start_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endAtMeta = const VerificationMeta('endAt');
  @override
  late final GeneratedColumn<DateTime> endAt = GeneratedColumn<DateTime>(
    'end_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
    'note',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    activityTypeId,
    startAt,
    endAt,
    note,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sessions';
  @override
  VerificationContext validateIntegrity(
    Insertable<Session> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('activity_type_id')) {
      context.handle(
        _activityTypeIdMeta,
        activityTypeId.isAcceptableOrUnknown(
          data['activity_type_id']!,
          _activityTypeIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_activityTypeIdMeta);
    }
    if (data.containsKey('start_at')) {
      context.handle(
        _startAtMeta,
        startAt.isAcceptableOrUnknown(data['start_at']!, _startAtMeta),
      );
    } else if (isInserting) {
      context.missing(_startAtMeta);
    }
    if (data.containsKey('end_at')) {
      context.handle(
        _endAtMeta,
        endAt.isAcceptableOrUnknown(data['end_at']!, _endAtMeta),
      );
    }
    if (data.containsKey('note')) {
      context.handle(
        _noteMeta,
        note.isAcceptableOrUnknown(data['note']!, _noteMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Session map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Session(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      activityTypeId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}activity_type_id'],
      )!,
      startAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}start_at'],
      )!,
      endAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}end_at'],
      ),
      note: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}note'],
      ),
    );
  }

  @override
  $SessionsTable createAlias(String alias) {
    return $SessionsTable(attachedDatabase, alias);
  }
}

class Session extends DataClass implements Insertable<Session> {
  final String id;

  /// Ссылка на тип активности
  final String activityTypeId;

  /// Время начала
  final DateTime startAt;

  /// Время окончания (null = активная сессия)
  final DateTime? endAt;

  /// Опциональная заметка
  final String? note;
  const Session({
    required this.id,
    required this.activityTypeId,
    required this.startAt,
    this.endAt,
    this.note,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['activity_type_id'] = Variable<String>(activityTypeId);
    map['start_at'] = Variable<DateTime>(startAt);
    if (!nullToAbsent || endAt != null) {
      map['end_at'] = Variable<DateTime>(endAt);
    }
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    return map;
  }

  SessionsCompanion toCompanion(bool nullToAbsent) {
    return SessionsCompanion(
      id: Value(id),
      activityTypeId: Value(activityTypeId),
      startAt: Value(startAt),
      endAt: endAt == null && nullToAbsent
          ? const Value.absent()
          : Value(endAt),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
    );
  }

  factory Session.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Session(
      id: serializer.fromJson<String>(json['id']),
      activityTypeId: serializer.fromJson<String>(json['activityTypeId']),
      startAt: serializer.fromJson<DateTime>(json['startAt']),
      endAt: serializer.fromJson<DateTime?>(json['endAt']),
      note: serializer.fromJson<String?>(json['note']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'activityTypeId': serializer.toJson<String>(activityTypeId),
      'startAt': serializer.toJson<DateTime>(startAt),
      'endAt': serializer.toJson<DateTime?>(endAt),
      'note': serializer.toJson<String?>(note),
    };
  }

  Session copyWith({
    String? id,
    String? activityTypeId,
    DateTime? startAt,
    Value<DateTime?> endAt = const Value.absent(),
    Value<String?> note = const Value.absent(),
  }) => Session(
    id: id ?? this.id,
    activityTypeId: activityTypeId ?? this.activityTypeId,
    startAt: startAt ?? this.startAt,
    endAt: endAt.present ? endAt.value : this.endAt,
    note: note.present ? note.value : this.note,
  );
  Session copyWithCompanion(SessionsCompanion data) {
    return Session(
      id: data.id.present ? data.id.value : this.id,
      activityTypeId: data.activityTypeId.present
          ? data.activityTypeId.value
          : this.activityTypeId,
      startAt: data.startAt.present ? data.startAt.value : this.startAt,
      endAt: data.endAt.present ? data.endAt.value : this.endAt,
      note: data.note.present ? data.note.value : this.note,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Session(')
          ..write('id: $id, ')
          ..write('activityTypeId: $activityTypeId, ')
          ..write('startAt: $startAt, ')
          ..write('endAt: $endAt, ')
          ..write('note: $note')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, activityTypeId, startAt, endAt, note);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Session &&
          other.id == this.id &&
          other.activityTypeId == this.activityTypeId &&
          other.startAt == this.startAt &&
          other.endAt == this.endAt &&
          other.note == this.note);
}

class SessionsCompanion extends UpdateCompanion<Session> {
  final Value<String> id;
  final Value<String> activityTypeId;
  final Value<DateTime> startAt;
  final Value<DateTime?> endAt;
  final Value<String?> note;
  final Value<int> rowid;
  const SessionsCompanion({
    this.id = const Value.absent(),
    this.activityTypeId = const Value.absent(),
    this.startAt = const Value.absent(),
    this.endAt = const Value.absent(),
    this.note = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SessionsCompanion.insert({
    required String id,
    required String activityTypeId,
    required DateTime startAt,
    this.endAt = const Value.absent(),
    this.note = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       activityTypeId = Value(activityTypeId),
       startAt = Value(startAt);
  static Insertable<Session> custom({
    Expression<String>? id,
    Expression<String>? activityTypeId,
    Expression<DateTime>? startAt,
    Expression<DateTime>? endAt,
    Expression<String>? note,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (activityTypeId != null) 'activity_type_id': activityTypeId,
      if (startAt != null) 'start_at': startAt,
      if (endAt != null) 'end_at': endAt,
      if (note != null) 'note': note,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SessionsCompanion copyWith({
    Value<String>? id,
    Value<String>? activityTypeId,
    Value<DateTime>? startAt,
    Value<DateTime?>? endAt,
    Value<String?>? note,
    Value<int>? rowid,
  }) {
    return SessionsCompanion(
      id: id ?? this.id,
      activityTypeId: activityTypeId ?? this.activityTypeId,
      startAt: startAt ?? this.startAt,
      endAt: endAt ?? this.endAt,
      note: note ?? this.note,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (activityTypeId.present) {
      map['activity_type_id'] = Variable<String>(activityTypeId.value);
    }
    if (startAt.present) {
      map['start_at'] = Variable<DateTime>(startAt.value);
    }
    if (endAt.present) {
      map['end_at'] = Variable<DateTime>(endAt.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SessionsCompanion(')
          ..write('id: $id, ')
          ..write('activityTypeId: $activityTypeId, ')
          ..write('startAt: $startAt, ')
          ..write('endAt: $endAt, ')
          ..write('note: $note, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TasksTable extends Tasks with TableInfo<$TasksTable, Task> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TasksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<TaskStatus, int> status =
      GeneratedColumn<int>(
        'status',
        aliasedName,
        false,
        type: DriftSqlType.int,
        requiredDuringInsert: true,
      ).withConverter<TaskStatus>($TasksTable.$converterstatus);
  static const VerificationMeta _deadlineMeta = const VerificationMeta(
    'deadline',
  );
  @override
  late final GeneratedColumn<DateTime> deadline = GeneratedColumn<DateTime>(
    'deadline',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<RepeatType, int> repeatType =
      GeneratedColumn<int>(
        'repeat_type',
        aliasedName,
        false,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
        defaultValue: const Constant(0),
      ).withConverter<RepeatType>($TasksTable.$converterrepeatType);
  static const VerificationMeta _repeatParamsMeta = const VerificationMeta(
    'repeatParams',
  );
  @override
  late final GeneratedColumn<String> repeatParams = GeneratedColumn<String>(
    'repeat_params',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _snoozeUntilMeta = const VerificationMeta(
    'snoozeUntil',
  );
  @override
  late final GeneratedColumn<DateTime> snoozeUntil = GeneratedColumn<DateTime>(
    'snooze_until',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    title,
    status,
    deadline,
    repeatType,
    repeatParams,
    snoozeUntil,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tasks';
  @override
  VerificationContext validateIntegrity(
    Insertable<Task> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('deadline')) {
      context.handle(
        _deadlineMeta,
        deadline.isAcceptableOrUnknown(data['deadline']!, _deadlineMeta),
      );
    }
    if (data.containsKey('repeat_params')) {
      context.handle(
        _repeatParamsMeta,
        repeatParams.isAcceptableOrUnknown(
          data['repeat_params']!,
          _repeatParamsMeta,
        ),
      );
    }
    if (data.containsKey('snooze_until')) {
      context.handle(
        _snoozeUntilMeta,
        snoozeUntil.isAcceptableOrUnknown(
          data['snooze_until']!,
          _snoozeUntilMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Task map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Task(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      status: $TasksTable.$converterstatus.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.int,
          data['${effectivePrefix}status'],
        )!,
      ),
      deadline: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deadline'],
      ),
      repeatType: $TasksTable.$converterrepeatType.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.int,
          data['${effectivePrefix}repeat_type'],
        )!,
      ),
      repeatParams: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}repeat_params'],
      ),
      snoozeUntil: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}snooze_until'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $TasksTable createAlias(String alias) {
    return $TasksTable(attachedDatabase, alias);
  }

  static JsonTypeConverter2<TaskStatus, int, int> $converterstatus =
      const EnumIndexConverter<TaskStatus>(TaskStatus.values);
  static JsonTypeConverter2<RepeatType, int, int> $converterrepeatType =
      const EnumIndexConverter<RepeatType>(RepeatType.values);
}

class Task extends DataClass implements Insertable<Task> {
  final String id;
  final String title;

  /// Статус: active, done, archived
  final TaskStatus status;

  /// Дедлайн (опционально)
  final DateTime? deadline;
  final RepeatType repeatType;

  /// JSON для хранения параметров повторения (дни недели, X, N)
  final String? repeatParams;

  /// Snooze до указанной даты
  final DateTime? snoozeUntil;
  final DateTime createdAt;
  const Task({
    required this.id,
    required this.title,
    required this.status,
    this.deadline,
    required this.repeatType,
    this.repeatParams,
    this.snoozeUntil,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['title'] = Variable<String>(title);
    {
      map['status'] = Variable<int>($TasksTable.$converterstatus.toSql(status));
    }
    if (!nullToAbsent || deadline != null) {
      map['deadline'] = Variable<DateTime>(deadline);
    }
    {
      map['repeat_type'] = Variable<int>(
        $TasksTable.$converterrepeatType.toSql(repeatType),
      );
    }
    if (!nullToAbsent || repeatParams != null) {
      map['repeat_params'] = Variable<String>(repeatParams);
    }
    if (!nullToAbsent || snoozeUntil != null) {
      map['snooze_until'] = Variable<DateTime>(snoozeUntil);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  TasksCompanion toCompanion(bool nullToAbsent) {
    return TasksCompanion(
      id: Value(id),
      title: Value(title),
      status: Value(status),
      deadline: deadline == null && nullToAbsent
          ? const Value.absent()
          : Value(deadline),
      repeatType: Value(repeatType),
      repeatParams: repeatParams == null && nullToAbsent
          ? const Value.absent()
          : Value(repeatParams),
      snoozeUntil: snoozeUntil == null && nullToAbsent
          ? const Value.absent()
          : Value(snoozeUntil),
      createdAt: Value(createdAt),
    );
  }

  factory Task.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Task(
      id: serializer.fromJson<String>(json['id']),
      title: serializer.fromJson<String>(json['title']),
      status: $TasksTable.$converterstatus.fromJson(
        serializer.fromJson<int>(json['status']),
      ),
      deadline: serializer.fromJson<DateTime?>(json['deadline']),
      repeatType: $TasksTable.$converterrepeatType.fromJson(
        serializer.fromJson<int>(json['repeatType']),
      ),
      repeatParams: serializer.fromJson<String?>(json['repeatParams']),
      snoozeUntil: serializer.fromJson<DateTime?>(json['snoozeUntil']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'title': serializer.toJson<String>(title),
      'status': serializer.toJson<int>(
        $TasksTable.$converterstatus.toJson(status),
      ),
      'deadline': serializer.toJson<DateTime?>(deadline),
      'repeatType': serializer.toJson<int>(
        $TasksTable.$converterrepeatType.toJson(repeatType),
      ),
      'repeatParams': serializer.toJson<String?>(repeatParams),
      'snoozeUntil': serializer.toJson<DateTime?>(snoozeUntil),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  Task copyWith({
    String? id,
    String? title,
    TaskStatus? status,
    Value<DateTime?> deadline = const Value.absent(),
    RepeatType? repeatType,
    Value<String?> repeatParams = const Value.absent(),
    Value<DateTime?> snoozeUntil = const Value.absent(),
    DateTime? createdAt,
  }) => Task(
    id: id ?? this.id,
    title: title ?? this.title,
    status: status ?? this.status,
    deadline: deadline.present ? deadline.value : this.deadline,
    repeatType: repeatType ?? this.repeatType,
    repeatParams: repeatParams.present ? repeatParams.value : this.repeatParams,
    snoozeUntil: snoozeUntil.present ? snoozeUntil.value : this.snoozeUntil,
    createdAt: createdAt ?? this.createdAt,
  );
  Task copyWithCompanion(TasksCompanion data) {
    return Task(
      id: data.id.present ? data.id.value : this.id,
      title: data.title.present ? data.title.value : this.title,
      status: data.status.present ? data.status.value : this.status,
      deadline: data.deadline.present ? data.deadline.value : this.deadline,
      repeatType: data.repeatType.present
          ? data.repeatType.value
          : this.repeatType,
      repeatParams: data.repeatParams.present
          ? data.repeatParams.value
          : this.repeatParams,
      snoozeUntil: data.snoozeUntil.present
          ? data.snoozeUntil.value
          : this.snoozeUntil,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Task(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('status: $status, ')
          ..write('deadline: $deadline, ')
          ..write('repeatType: $repeatType, ')
          ..write('repeatParams: $repeatParams, ')
          ..write('snoozeUntil: $snoozeUntil, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    title,
    status,
    deadline,
    repeatType,
    repeatParams,
    snoozeUntil,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Task &&
          other.id == this.id &&
          other.title == this.title &&
          other.status == this.status &&
          other.deadline == this.deadline &&
          other.repeatType == this.repeatType &&
          other.repeatParams == this.repeatParams &&
          other.snoozeUntil == this.snoozeUntil &&
          other.createdAt == this.createdAt);
}

class TasksCompanion extends UpdateCompanion<Task> {
  final Value<String> id;
  final Value<String> title;
  final Value<TaskStatus> status;
  final Value<DateTime?> deadline;
  final Value<RepeatType> repeatType;
  final Value<String?> repeatParams;
  final Value<DateTime?> snoozeUntil;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const TasksCompanion({
    this.id = const Value.absent(),
    this.title = const Value.absent(),
    this.status = const Value.absent(),
    this.deadline = const Value.absent(),
    this.repeatType = const Value.absent(),
    this.repeatParams = const Value.absent(),
    this.snoozeUntil = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TasksCompanion.insert({
    required String id,
    required String title,
    required TaskStatus status,
    this.deadline = const Value.absent(),
    this.repeatType = const Value.absent(),
    this.repeatParams = const Value.absent(),
    this.snoozeUntil = const Value.absent(),
    required DateTime createdAt,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       title = Value(title),
       status = Value(status),
       createdAt = Value(createdAt);
  static Insertable<Task> custom({
    Expression<String>? id,
    Expression<String>? title,
    Expression<int>? status,
    Expression<DateTime>? deadline,
    Expression<int>? repeatType,
    Expression<String>? repeatParams,
    Expression<DateTime>? snoozeUntil,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (title != null) 'title': title,
      if (status != null) 'status': status,
      if (deadline != null) 'deadline': deadline,
      if (repeatType != null) 'repeat_type': repeatType,
      if (repeatParams != null) 'repeat_params': repeatParams,
      if (snoozeUntil != null) 'snooze_until': snoozeUntil,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TasksCompanion copyWith({
    Value<String>? id,
    Value<String>? title,
    Value<TaskStatus>? status,
    Value<DateTime?>? deadline,
    Value<RepeatType>? repeatType,
    Value<String?>? repeatParams,
    Value<DateTime?>? snoozeUntil,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return TasksCompanion(
      id: id ?? this.id,
      title: title ?? this.title,
      status: status ?? this.status,
      deadline: deadline ?? this.deadline,
      repeatType: repeatType ?? this.repeatType,
      repeatParams: repeatParams ?? this.repeatParams,
      snoozeUntil: snoozeUntil ?? this.snoozeUntil,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (status.present) {
      map['status'] = Variable<int>(
        $TasksTable.$converterstatus.toSql(status.value),
      );
    }
    if (deadline.present) {
      map['deadline'] = Variable<DateTime>(deadline.value);
    }
    if (repeatType.present) {
      map['repeat_type'] = Variable<int>(
        $TasksTable.$converterrepeatType.toSql(repeatType.value),
      );
    }
    if (repeatParams.present) {
      map['repeat_params'] = Variable<String>(repeatParams.value);
    }
    if (snoozeUntil.present) {
      map['snooze_until'] = Variable<DateTime>(snoozeUntil.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TasksCompanion(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('status: $status, ')
          ..write('deadline: $deadline, ')
          ..write('repeatType: $repeatType, ')
          ..write('repeatParams: $repeatParams, ')
          ..write('snoozeUntil: $snoozeUntil, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TaskCompletionsTable extends TaskCompletions
    with TableInfo<$TaskCompletionsTable, TaskCompletion> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TaskCompletionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _taskIdMeta = const VerificationMeta('taskId');
  @override
  late final GeneratedColumn<String> taskId = GeneratedColumn<String>(
    'task_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES tasks (id)',
    ),
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [id, taskId, completedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'task_completions';
  @override
  VerificationContext validateIntegrity(
    Insertable<TaskCompletion> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('task_id')) {
      context.handle(
        _taskIdMeta,
        taskId.isAcceptableOrUnknown(data['task_id']!, _taskIdMeta),
      );
    } else if (isInserting) {
      context.missing(_taskIdMeta);
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_completedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  TaskCompletion map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaskCompletion(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      taskId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}task_id'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      )!,
    );
  }

  @override
  $TaskCompletionsTable createAlias(String alias) {
    return $TaskCompletionsTable(attachedDatabase, alias);
  }
}

class TaskCompletion extends DataClass implements Insertable<TaskCompletion> {
  final int id;
  final String taskId;
  final DateTime completedAt;
  const TaskCompletion({
    required this.id,
    required this.taskId,
    required this.completedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['task_id'] = Variable<String>(taskId);
    map['completed_at'] = Variable<DateTime>(completedAt);
    return map;
  }

  TaskCompletionsCompanion toCompanion(bool nullToAbsent) {
    return TaskCompletionsCompanion(
      id: Value(id),
      taskId: Value(taskId),
      completedAt: Value(completedAt),
    );
  }

  factory TaskCompletion.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaskCompletion(
      id: serializer.fromJson<int>(json['id']),
      taskId: serializer.fromJson<String>(json['taskId']),
      completedAt: serializer.fromJson<DateTime>(json['completedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'taskId': serializer.toJson<String>(taskId),
      'completedAt': serializer.toJson<DateTime>(completedAt),
    };
  }

  TaskCompletion copyWith({int? id, String? taskId, DateTime? completedAt}) =>
      TaskCompletion(
        id: id ?? this.id,
        taskId: taskId ?? this.taskId,
        completedAt: completedAt ?? this.completedAt,
      );
  TaskCompletion copyWithCompanion(TaskCompletionsCompanion data) {
    return TaskCompletion(
      id: data.id.present ? data.id.value : this.id,
      taskId: data.taskId.present ? data.taskId.value : this.taskId,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TaskCompletion(')
          ..write('id: $id, ')
          ..write('taskId: $taskId, ')
          ..write('completedAt: $completedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, taskId, completedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaskCompletion &&
          other.id == this.id &&
          other.taskId == this.taskId &&
          other.completedAt == this.completedAt);
}

class TaskCompletionsCompanion extends UpdateCompanion<TaskCompletion> {
  final Value<int> id;
  final Value<String> taskId;
  final Value<DateTime> completedAt;
  const TaskCompletionsCompanion({
    this.id = const Value.absent(),
    this.taskId = const Value.absent(),
    this.completedAt = const Value.absent(),
  });
  TaskCompletionsCompanion.insert({
    this.id = const Value.absent(),
    required String taskId,
    required DateTime completedAt,
  }) : taskId = Value(taskId),
       completedAt = Value(completedAt);
  static Insertable<TaskCompletion> custom({
    Expression<int>? id,
    Expression<String>? taskId,
    Expression<DateTime>? completedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (taskId != null) 'task_id': taskId,
      if (completedAt != null) 'completed_at': completedAt,
    });
  }

  TaskCompletionsCompanion copyWith({
    Value<int>? id,
    Value<String>? taskId,
    Value<DateTime>? completedAt,
  }) {
    return TaskCompletionsCompanion(
      id: id ?? this.id,
      taskId: taskId ?? this.taskId,
      completedAt: completedAt ?? this.completedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (taskId.present) {
      map['task_id'] = Variable<String>(taskId.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaskCompletionsCompanion(')
          ..write('id: $id, ')
          ..write('taskId: $taskId, ')
          ..write('completedAt: $completedAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $ActivityTypesTable activityTypes = $ActivityTypesTable(this);
  late final $SessionsTable sessions = $SessionsTable(this);
  late final $TasksTable tasks = $TasksTable(this);
  late final $TaskCompletionsTable taskCompletions = $TaskCompletionsTable(
    this,
  );
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    activityTypes,
    sessions,
    tasks,
    taskCompletions,
  ];
}

typedef $$ActivityTypesTableCreateCompanionBuilder =
    ActivityTypesCompanion Function({
      required String id,
      required String name,
      required String color,
      required int order,
      Value<bool> isHidden,
      Value<int> rowid,
    });
typedef $$ActivityTypesTableUpdateCompanionBuilder =
    ActivityTypesCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> color,
      Value<int> order,
      Value<bool> isHidden,
      Value<int> rowid,
    });

final class $$ActivityTypesTableReferences
    extends BaseReferences<_$AppDatabase, $ActivityTypesTable, ActivityType> {
  $$ActivityTypesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static MultiTypedResultKey<$SessionsTable, List<Session>> _sessionsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.sessions,
    aliasName: $_aliasNameGenerator(
      db.activityTypes.id,
      db.sessions.activityTypeId,
    ),
  );

  $$SessionsTableProcessedTableManager get sessionsRefs {
    final manager = $$SessionsTableTableManager(
      $_db,
      $_db.sessions,
    ).filter((f) => f.activityTypeId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_sessionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ActivityTypesTableFilterComposer
    extends Composer<_$AppDatabase, $ActivityTypesTable> {
  $$ActivityTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get order => $composableBuilder(
    column: $table.order,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isHidden => $composableBuilder(
    column: $table.isHidden,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> sessionsRefs(
    Expression<bool> Function($$SessionsTableFilterComposer f) f,
  ) {
    final $$SessionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.activityTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableFilterComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ActivityTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivityTypesTable> {
  $$ActivityTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get color => $composableBuilder(
    column: $table.color,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get order => $composableBuilder(
    column: $table.order,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isHidden => $composableBuilder(
    column: $table.isHidden,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActivityTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivityTypesTable> {
  $$ActivityTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get color =>
      $composableBuilder(column: $table.color, builder: (column) => column);

  GeneratedColumn<int> get order =>
      $composableBuilder(column: $table.order, builder: (column) => column);

  GeneratedColumn<bool> get isHidden =>
      $composableBuilder(column: $table.isHidden, builder: (column) => column);

  Expression<T> sessionsRefs<T extends Object>(
    Expression<T> Function($$SessionsTableAnnotationComposer a) f,
  ) {
    final $$SessionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.sessions,
      getReferencedColumn: (t) => t.activityTypeId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SessionsTableAnnotationComposer(
            $db: $db,
            $table: $db.sessions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ActivityTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivityTypesTable,
          ActivityType,
          $$ActivityTypesTableFilterComposer,
          $$ActivityTypesTableOrderingComposer,
          $$ActivityTypesTableAnnotationComposer,
          $$ActivityTypesTableCreateCompanionBuilder,
          $$ActivityTypesTableUpdateCompanionBuilder,
          (ActivityType, $$ActivityTypesTableReferences),
          ActivityType,
          PrefetchHooks Function({bool sessionsRefs})
        > {
  $$ActivityTypesTableTableManager(_$AppDatabase db, $ActivityTypesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivityTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivityTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivityTypesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> color = const Value.absent(),
                Value<int> order = const Value.absent(),
                Value<bool> isHidden = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityTypesCompanion(
                id: id,
                name: name,
                color: color,
                order: order,
                isHidden: isHidden,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String color,
                required int order,
                Value<bool> isHidden = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityTypesCompanion.insert(
                id: id,
                name: name,
                color: color,
                order: order,
                isHidden: isHidden,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ActivityTypesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({sessionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (sessionsRefs) db.sessions],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (sessionsRefs)
                    await $_getPrefetchedData<
                      ActivityType,
                      $ActivityTypesTable,
                      Session
                    >(
                      currentTable: table,
                      referencedTable: $$ActivityTypesTableReferences
                          ._sessionsRefsTable(db),
                      managerFromTypedResult: (p0) =>
                          $$ActivityTypesTableReferences(
                            db,
                            table,
                            p0,
                          ).sessionsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where(
                            (e) => e.activityTypeId == item.id,
                          ),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$ActivityTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivityTypesTable,
      ActivityType,
      $$ActivityTypesTableFilterComposer,
      $$ActivityTypesTableOrderingComposer,
      $$ActivityTypesTableAnnotationComposer,
      $$ActivityTypesTableCreateCompanionBuilder,
      $$ActivityTypesTableUpdateCompanionBuilder,
      (ActivityType, $$ActivityTypesTableReferences),
      ActivityType,
      PrefetchHooks Function({bool sessionsRefs})
    >;
typedef $$SessionsTableCreateCompanionBuilder =
    SessionsCompanion Function({
      required String id,
      required String activityTypeId,
      required DateTime startAt,
      Value<DateTime?> endAt,
      Value<String?> note,
      Value<int> rowid,
    });
typedef $$SessionsTableUpdateCompanionBuilder =
    SessionsCompanion Function({
      Value<String> id,
      Value<String> activityTypeId,
      Value<DateTime> startAt,
      Value<DateTime?> endAt,
      Value<String?> note,
      Value<int> rowid,
    });

final class $$SessionsTableReferences
    extends BaseReferences<_$AppDatabase, $SessionsTable, Session> {
  $$SessionsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ActivityTypesTable _activityTypeIdTable(_$AppDatabase db) =>
      db.activityTypes.createAlias(
        $_aliasNameGenerator(db.sessions.activityTypeId, db.activityTypes.id),
      );

  $$ActivityTypesTableProcessedTableManager get activityTypeId {
    final $_column = $_itemColumn<String>('activity_type_id')!;

    final manager = $$ActivityTypesTableTableManager(
      $_db,
      $_db.activityTypes,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_activityTypeIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SessionsTableFilterComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startAt => $composableBuilder(
    column: $table.startAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get endAt => $composableBuilder(
    column: $table.endAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get note => $composableBuilder(
    column: $table.note,
    builder: (column) => ColumnFilters(column),
  );

  $$ActivityTypesTableFilterComposer get activityTypeId {
    final $$ActivityTypesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityTypeId,
      referencedTable: $db.activityTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityTypesTableFilterComposer(
            $db: $db,
            $table: $db.activityTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SessionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startAt => $composableBuilder(
    column: $table.startAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get endAt => $composableBuilder(
    column: $table.endAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get note => $composableBuilder(
    column: $table.note,
    builder: (column) => ColumnOrderings(column),
  );

  $$ActivityTypesTableOrderingComposer get activityTypeId {
    final $$ActivityTypesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityTypeId,
      referencedTable: $db.activityTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityTypesTableOrderingComposer(
            $db: $db,
            $table: $db.activityTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SessionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SessionsTable> {
  $$SessionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get startAt =>
      $composableBuilder(column: $table.startAt, builder: (column) => column);

  GeneratedColumn<DateTime> get endAt =>
      $composableBuilder(column: $table.endAt, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  $$ActivityTypesTableAnnotationComposer get activityTypeId {
    final $$ActivityTypesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.activityTypeId,
      referencedTable: $db.activityTypes,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityTypesTableAnnotationComposer(
            $db: $db,
            $table: $db.activityTypes,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SessionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SessionsTable,
          Session,
          $$SessionsTableFilterComposer,
          $$SessionsTableOrderingComposer,
          $$SessionsTableAnnotationComposer,
          $$SessionsTableCreateCompanionBuilder,
          $$SessionsTableUpdateCompanionBuilder,
          (Session, $$SessionsTableReferences),
          Session,
          PrefetchHooks Function({bool activityTypeId})
        > {
  $$SessionsTableTableManager(_$AppDatabase db, $SessionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SessionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SessionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SessionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> activityTypeId = const Value.absent(),
                Value<DateTime> startAt = const Value.absent(),
                Value<DateTime?> endAt = const Value.absent(),
                Value<String?> note = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SessionsCompanion(
                id: id,
                activityTypeId: activityTypeId,
                startAt: startAt,
                endAt: endAt,
                note: note,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String activityTypeId,
                required DateTime startAt,
                Value<DateTime?> endAt = const Value.absent(),
                Value<String?> note = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SessionsCompanion.insert(
                id: id,
                activityTypeId: activityTypeId,
                startAt: startAt,
                endAt: endAt,
                note: note,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SessionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({activityTypeId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (activityTypeId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.activityTypeId,
                                referencedTable: $$SessionsTableReferences
                                    ._activityTypeIdTable(db),
                                referencedColumn: $$SessionsTableReferences
                                    ._activityTypeIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SessionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SessionsTable,
      Session,
      $$SessionsTableFilterComposer,
      $$SessionsTableOrderingComposer,
      $$SessionsTableAnnotationComposer,
      $$SessionsTableCreateCompanionBuilder,
      $$SessionsTableUpdateCompanionBuilder,
      (Session, $$SessionsTableReferences),
      Session,
      PrefetchHooks Function({bool activityTypeId})
    >;
typedef $$TasksTableCreateCompanionBuilder =
    TasksCompanion Function({
      required String id,
      required String title,
      required TaskStatus status,
      Value<DateTime?> deadline,
      Value<RepeatType> repeatType,
      Value<String?> repeatParams,
      Value<DateTime?> snoozeUntil,
      required DateTime createdAt,
      Value<int> rowid,
    });
typedef $$TasksTableUpdateCompanionBuilder =
    TasksCompanion Function({
      Value<String> id,
      Value<String> title,
      Value<TaskStatus> status,
      Value<DateTime?> deadline,
      Value<RepeatType> repeatType,
      Value<String?> repeatParams,
      Value<DateTime?> snoozeUntil,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$TasksTableReferences
    extends BaseReferences<_$AppDatabase, $TasksTable, Task> {
  $$TasksTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$TaskCompletionsTable, List<TaskCompletion>>
  _taskCompletionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.taskCompletions,
    aliasName: $_aliasNameGenerator(db.tasks.id, db.taskCompletions.taskId),
  );

  $$TaskCompletionsTableProcessedTableManager get taskCompletionsRefs {
    final manager = $$TaskCompletionsTableTableManager(
      $_db,
      $_db.taskCompletions,
    ).filter((f) => f.taskId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _taskCompletionsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$TasksTableFilterComposer extends Composer<_$AppDatabase, $TasksTable> {
  $$TasksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<TaskStatus, TaskStatus, int> get status =>
      $composableBuilder(
        column: $table.status,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<DateTime> get deadline => $composableBuilder(
    column: $table.deadline,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<RepeatType, RepeatType, int> get repeatType =>
      $composableBuilder(
        column: $table.repeatType,
        builder: (column) => ColumnWithTypeConverterFilters(column),
      );

  ColumnFilters<String> get repeatParams => $composableBuilder(
    column: $table.repeatParams,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get snoozeUntil => $composableBuilder(
    column: $table.snoozeUntil,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> taskCompletionsRefs(
    Expression<bool> Function($$TaskCompletionsTableFilterComposer f) f,
  ) {
    final $$TaskCompletionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.taskCompletions,
      getReferencedColumn: (t) => t.taskId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TaskCompletionsTableFilterComposer(
            $db: $db,
            $table: $db.taskCompletions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$TasksTableOrderingComposer
    extends Composer<_$AppDatabase, $TasksTable> {
  $$TasksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deadline => $composableBuilder(
    column: $table.deadline,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get repeatType => $composableBuilder(
    column: $table.repeatType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get repeatParams => $composableBuilder(
    column: $table.repeatParams,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get snoozeUntil => $composableBuilder(
    column: $table.snoozeUntil,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$TasksTableAnnotationComposer
    extends Composer<_$AppDatabase, $TasksTable> {
  $$TasksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumnWithTypeConverter<TaskStatus, int> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get deadline =>
      $composableBuilder(column: $table.deadline, builder: (column) => column);

  GeneratedColumnWithTypeConverter<RepeatType, int> get repeatType =>
      $composableBuilder(
        column: $table.repeatType,
        builder: (column) => column,
      );

  GeneratedColumn<String> get repeatParams => $composableBuilder(
    column: $table.repeatParams,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get snoozeUntil => $composableBuilder(
    column: $table.snoozeUntil,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> taskCompletionsRefs<T extends Object>(
    Expression<T> Function($$TaskCompletionsTableAnnotationComposer a) f,
  ) {
    final $$TaskCompletionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.taskCompletions,
      getReferencedColumn: (t) => t.taskId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TaskCompletionsTableAnnotationComposer(
            $db: $db,
            $table: $db.taskCompletions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$TasksTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $TasksTable,
          Task,
          $$TasksTableFilterComposer,
          $$TasksTableOrderingComposer,
          $$TasksTableAnnotationComposer,
          $$TasksTableCreateCompanionBuilder,
          $$TasksTableUpdateCompanionBuilder,
          (Task, $$TasksTableReferences),
          Task,
          PrefetchHooks Function({bool taskCompletionsRefs})
        > {
  $$TasksTableTableManager(_$AppDatabase db, $TasksTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TasksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TasksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TasksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<TaskStatus> status = const Value.absent(),
                Value<DateTime?> deadline = const Value.absent(),
                Value<RepeatType> repeatType = const Value.absent(),
                Value<String?> repeatParams = const Value.absent(),
                Value<DateTime?> snoozeUntil = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => TasksCompanion(
                id: id,
                title: title,
                status: status,
                deadline: deadline,
                repeatType: repeatType,
                repeatParams: repeatParams,
                snoozeUntil: snoozeUntil,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String title,
                required TaskStatus status,
                Value<DateTime?> deadline = const Value.absent(),
                Value<RepeatType> repeatType = const Value.absent(),
                Value<String?> repeatParams = const Value.absent(),
                Value<DateTime?> snoozeUntil = const Value.absent(),
                required DateTime createdAt,
                Value<int> rowid = const Value.absent(),
              }) => TasksCompanion.insert(
                id: id,
                title: title,
                status: status,
                deadline: deadline,
                repeatType: repeatType,
                repeatParams: repeatParams,
                snoozeUntil: snoozeUntil,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$TasksTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({taskCompletionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (taskCompletionsRefs) db.taskCompletions,
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (taskCompletionsRefs)
                    await $_getPrefetchedData<
                      Task,
                      $TasksTable,
                      TaskCompletion
                    >(
                      currentTable: table,
                      referencedTable: $$TasksTableReferences
                          ._taskCompletionsRefsTable(db),
                      managerFromTypedResult: (p0) => $$TasksTableReferences(
                        db,
                        table,
                        p0,
                      ).taskCompletionsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.taskId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$TasksTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $TasksTable,
      Task,
      $$TasksTableFilterComposer,
      $$TasksTableOrderingComposer,
      $$TasksTableAnnotationComposer,
      $$TasksTableCreateCompanionBuilder,
      $$TasksTableUpdateCompanionBuilder,
      (Task, $$TasksTableReferences),
      Task,
      PrefetchHooks Function({bool taskCompletionsRefs})
    >;
typedef $$TaskCompletionsTableCreateCompanionBuilder =
    TaskCompletionsCompanion Function({
      Value<int> id,
      required String taskId,
      required DateTime completedAt,
    });
typedef $$TaskCompletionsTableUpdateCompanionBuilder =
    TaskCompletionsCompanion Function({
      Value<int> id,
      Value<String> taskId,
      Value<DateTime> completedAt,
    });

final class $$TaskCompletionsTableReferences
    extends
        BaseReferences<_$AppDatabase, $TaskCompletionsTable, TaskCompletion> {
  $$TaskCompletionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $TasksTable _taskIdTable(_$AppDatabase db) => db.tasks.createAlias(
    $_aliasNameGenerator(db.taskCompletions.taskId, db.tasks.id),
  );

  $$TasksTableProcessedTableManager get taskId {
    final $_column = $_itemColumn<String>('task_id')!;

    final manager = $$TasksTableTableManager(
      $_db,
      $_db.tasks,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_taskIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$TaskCompletionsTableFilterComposer
    extends Composer<_$AppDatabase, $TaskCompletionsTable> {
  $$TaskCompletionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$TasksTableFilterComposer get taskId {
    final $$TasksTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.taskId,
      referencedTable: $db.tasks,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TasksTableFilterComposer(
            $db: $db,
            $table: $db.tasks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TaskCompletionsTableOrderingComposer
    extends Composer<_$AppDatabase, $TaskCompletionsTable> {
  $$TaskCompletionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$TasksTableOrderingComposer get taskId {
    final $$TasksTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.taskId,
      referencedTable: $db.tasks,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TasksTableOrderingComposer(
            $db: $db,
            $table: $db.tasks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TaskCompletionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $TaskCompletionsTable> {
  $$TaskCompletionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  $$TasksTableAnnotationComposer get taskId {
    final $$TasksTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.taskId,
      referencedTable: $db.tasks,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$TasksTableAnnotationComposer(
            $db: $db,
            $table: $db.tasks,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$TaskCompletionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $TaskCompletionsTable,
          TaskCompletion,
          $$TaskCompletionsTableFilterComposer,
          $$TaskCompletionsTableOrderingComposer,
          $$TaskCompletionsTableAnnotationComposer,
          $$TaskCompletionsTableCreateCompanionBuilder,
          $$TaskCompletionsTableUpdateCompanionBuilder,
          (TaskCompletion, $$TaskCompletionsTableReferences),
          TaskCompletion,
          PrefetchHooks Function({bool taskId})
        > {
  $$TaskCompletionsTableTableManager(
    _$AppDatabase db,
    $TaskCompletionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TaskCompletionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TaskCompletionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TaskCompletionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> taskId = const Value.absent(),
                Value<DateTime> completedAt = const Value.absent(),
              }) => TaskCompletionsCompanion(
                id: id,
                taskId: taskId,
                completedAt: completedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String taskId,
                required DateTime completedAt,
              }) => TaskCompletionsCompanion.insert(
                id: id,
                taskId: taskId,
                completedAt: completedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$TaskCompletionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({taskId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (taskId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.taskId,
                                referencedTable:
                                    $$TaskCompletionsTableReferences
                                        ._taskIdTable(db),
                                referencedColumn:
                                    $$TaskCompletionsTableReferences
                                        ._taskIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$TaskCompletionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $TaskCompletionsTable,
      TaskCompletion,
      $$TaskCompletionsTableFilterComposer,
      $$TaskCompletionsTableOrderingComposer,
      $$TaskCompletionsTableAnnotationComposer,
      $$TaskCompletionsTableCreateCompanionBuilder,
      $$TaskCompletionsTableUpdateCompanionBuilder,
      (TaskCompletion, $$TaskCompletionsTableReferences),
      TaskCompletion,
      PrefetchHooks Function({bool taskId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$ActivityTypesTableTableManager get activityTypes =>
      $$ActivityTypesTableTableManager(_db, _db.activityTypes);
  $$SessionsTableTableManager get sessions =>
      $$SessionsTableTableManager(_db, _db.sessions);
  $$TasksTableTableManager get tasks =>
      $$TasksTableTableManager(_db, _db.tasks);
  $$TaskCompletionsTableTableManager get taskCompletions =>
      $$TaskCompletionsTableTableManager(_db, _db.taskCompletions);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/data/database/drift_database.dart drift_database.dart
import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

part 'drift_database.g.dart';

/// Таблица типов активности (Study, Code, Gym, Sleep и т.д.)
class ActivityTypes extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  /// Цвет в формате #RRGGBB
  TextColumn get color => text()();
  /// Порядок отображения в UI
  IntColumn get order => integer()();
  /// Скрыть из календаря
  BoolColumn get isHidden => boolean().withDefault(const Constant(false))();
  
  @override
  Set<Column> get primaryKey => {id};
}

/// Таблица сессий активности
class Sessions extends Table {
  TextColumn get id => text()();
  /// Ссылка на тип активности
  TextColumn get activityTypeId => text().references(ActivityTypes, #id)();
  /// Время начала
  DateTimeColumn get startAt => dateTime()();
  /// Время окончания (null = активная сессия)
  DateTimeColumn get endAt => dateTime().nullable()();
  /// Опциональная заметка
  TextColumn get note => text().nullable()();
  
  @override
  Set<Column> get primaryKey => {id};
}

/// Статусы задач
enum TaskStatus {
  active,
  done,
  archived,
}

/// Типы правил повторения
enum RepeatType {
  none,
  fixedSchedule,     // дни недели
  xTimesInNDays,     // X раз за N дней
  everyNDaysAfterCompletion, // каждые N дней после выполнения
}

/// Таблица задач
class Tasks extends Table {
  TextColumn get id => text()();
  TextColumn get title => text()();
  /// Статус: active, done, archived
  IntColumn get status => intEnum<TaskStatus>()();
  /// Дедлайн (опционально)
  DateTimeColumn get deadline => dateTime().nullable()();
  
  // Правило повторения
  IntColumn get repeatType => intEnum<RepeatType>().withDefault(const Constant(0))();
  /// JSON для хранения параметров повторения (дни недели, X, N)
  TextColumn get repeatParams => text().nullable()();
  
  /// Snooze до указанной даты
  DateTimeColumn get snoozeUntil => dateTime().nullable()();
  
  DateTimeColumn get createdAt => dateTime()();
  
  @override
  Set<Column> get primaryKey => {id};
}

/// Таблица истории выполнений для повторяющихся задач
class TaskCompletions extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get taskId => text().references(Tasks, #id)();
  DateTimeColumn get completedAt => dateTime()();
}

@DriftDatabase(
  tables: [ActivityTypes, Sessions, Tasks, TaskCompletions],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  // ============================================================
  // Session Queries
  // ============================================================
  
  /// Получить активную сессию (где endAt = null)
  Stream<Session?> watchActiveSession() {
    return (select(sessions)
          ..where((s) => s.endAt.isNull())
          ..limit(1))
        .watchSingleOrNull();
  }

  /// Получить сессии за период с join на activity_types
  Stream<List<SessionWithActivityType>> watchSessionsForPeriod({
    required DateTime from,
    required DateTime to,
  }) {
    final query = select(sessions).join([
      leftOuterJoin(activityTypes, activityTypes.id.equalsExp(sessions.activityTypeId)),
    ])
      ..where(sessions.startAt.isBiggerOrEqualValue(from) & sessions.startAt.isSmallerThanValue(to))
      ..orderBy([OrderingTerm.asc(sessions.startAt)]);

    return query.watch().map((rows) {
      return rows.map((row) {
        return SessionWithActivityType(
          session: row.readTable(sessions),
          activityType: row.readTableOrNull(activityTypes),
        );
      }).toList();
    });
  }

  /// Детекция конфликтов: найти сессии, которые пересекаются с candidateStart-candidateEnd
  Future<List<Session>> detectConflicts({
    required DateTime candidateStart,
    required DateTime candidateEnd,
    String? excludeSessionId, // Для редактирования существующей сессии
  }) {
    final query = select(sessions)
      ..where((s) {
        // Пересечение: (s.startAt < candidateEnd) AND ((s.endAt > candidateStart) OR (s.endAt IS NULL))
        // Если endAt is null -> сессия активна (бесконечна в будущем), значит она пересекается
        // с любой сессией, которая начинается после её начала (candidateStart < infinity)
        
        final sessionEndIsNull = s.endAt.isNull();
        final sessionEndIsAfterCandidateStart = s.endAt.isBiggerThanValue(candidateStart);
        
        final overlap = s.startAt.isSmallerThanValue(candidateEnd) & 
                        (sessionEndIsAfterCandidateStart | sessionEndIsNull);
        
        if (excludeSessionId != null) {
          return overlap & s.id.equals(excludeSessionId).not();
        }
        return overlap;
      });
    
    return query.get();
  }

  /// Получить все сессии за конкретный день
  Future<List<Session>> getSessionsForDay(DateTime day) {
    final startOfDay = DateTime(day.year, day.month, day.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));
    
    return (select(sessions)
          ..where((s) => 
              s.startAt.isBiggerOrEqualValue(startOfDay) & 
              s.startAt.isSmallerThanValue(endOfDay))
          ..orderBy([(s) => OrderingTerm.asc(s.startAt)]))
        .get();
  }

  // ============================================================
  // Activity Type Queries
  // ============================================================
  
  Stream<List<ActivityType>> watchActivityTypes() {
    return (select(activityTypes)
          ..orderBy([(a) => OrderingTerm.asc(a.order)]))
        .watch();
  }

  Future<int> createActivityType(ActivityTypesCompanion activityType) {
    return into(activityTypes).insert(activityType);
  }

  Future<bool> updateActivityType(ActivityType activityType) {
    return update(activityTypes).replace(activityType);
  }

  Future<int> deleteActivityType(String id) {
    return (delete(activityTypes)..where((a) => a.id.equals(id))).go();
  }

  // ============================================================
  // Task Queries
  // ============================================================

  Stream<List<Task>> watchTasksByStatus(TaskStatus? status) {
    if (status == null) {
      return select(tasks).watch();
    }
    return (select(tasks)..where((t) => t.status.equalsValue(status))).watch();
  }

  Future<List<Task>> getOverdueTasks() {
    final now = DateTime.now();
    return (select(tasks)
          ..where((t) => 
              t.status.equalsValue(TaskStatus.active) & 
              t.deadline.isNotNull() & 
              t.deadline.isSmallerThanValue(now)))
        .get();
  }

  Future<int> createTask(TasksCompanion task) {
    return into(tasks).insert(task);
  }

  Future<bool> updateTask(Task task) {
    return update(tasks).replace(task);
  }

  Future<int> deleteTask(String id) {
    return (delete(tasks)..where((t) => t.id.equals(id))).go();
  }

  // ============================================================
  // Session CRUD
  // ============================================================

  Future<int> createSession(SessionsCompanion session) {
    return into(sessions).insert(session);
  }

  Future<bool> updateSession(Session session) {
    return update(sessions).replace(session);
  }

  Future<int> deleteSession(String id) {
    return (delete(sessions)..where((s) => s.id.equals(id))).go();
  }

  /// Остановить активную сессию
  Future<void> stopActiveSession(DateTime endTime) async {
    final activeSession = await watchActiveSession().first;
    if (activeSession != null) {
      await (update(sessions)..where((s) => s.id.equals(activeSession.id)))
          .write(SessionsCompanion(endAt: Value(endTime)));
    }
  }
}

/// Value class для сессии с информацией о типе активности
class SessionWithActivityType {
  final Session session;
  final ActivityType? activityType;

  SessionWithActivityType({
    required this.session,
    required this.activityType,
  });
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'tempo_db.sqlite'));
    return NativeDatabase(file);
  });
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/dialogs/activity_editor_dialog.dart activity_editor_dialog.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors; 
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/use_case_providers.dart';
import 'package:tempo/src/domain/entities/activity_type.dart';

class ActivityEditorDialog extends ConsumerStatefulWidget {
  final ActivityType? activityToEdit;

  const ActivityEditorDialog({super.key, this.activityToEdit});

  @override
  ConsumerState<ActivityEditorDialog> createState() => _ActivityEditorDialogState();
}

class _ActivityEditorDialogState extends ConsumerState<ActivityEditorDialog> {
  late TextEditingController _nameController;
  late String _selectedColor;

  static const List<String> _colors = [
    '#007AFF', // Blue
    '#AF52DE', // Purple
    '#FF9500', // Orange
    '#FF3B30', // Red
    '#34C759', // Green
    '#5AC8FA', // Teal
    '#FFCC00', // Yellow
    '#5856D6', // Indigo
    '#8E8E93', // Grey
  ];

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.activityToEdit?.name ?? '');
    _selectedColor = widget.activityToEdit?.color ?? _colors.first;
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  void _save() {
    final name = _nameController.text.trim();
    if (name.isEmpty) return; // Show error?

    if (widget.activityToEdit != null) {
      final updated = widget.activityToEdit!.copyWith(
        name: name,
        color: _selectedColor,
      );
      ref.read(updateActivityTypeUseCaseProvider).call(updated);
    } else {
      ref.read(createActivityTypeUseCaseProvider).call(name, _selectedColor);
    }
    
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      decoration: const BoxDecoration(
        color: CupertinoColors.systemBackground,
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      child: Column(
        children: [
          // Header
          SizedBox(
            height: 56,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                CupertinoButton(
                  child: const Text('Cancel'),
                  onPressed: () => Navigator.of(context).pop(),
                ),
                Text(
                  widget.activityToEdit != null ? 'Edit Activity' : 'New Activity',
                  style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 17),
                ),
                CupertinoButton(
                  onPressed: _nameController.text.isNotEmpty ? _save : null,
                  child: const Text('Save', style: TextStyle(fontWeight: FontWeight.w600)),
                ),
              ],
            ),
          ),
          Container(height: 1, color: CupertinoColors.separator),
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(20),
              children: [
                // Name Input
                CupertinoTextField(
                  controller: _nameController,
                  placeholder: 'Activity Name',
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: CupertinoColors.secondarySystemBackground, // DynamicColor
                    borderRadius: BorderRadius.circular(12),
                  ),
                  onChanged: (val) => setState(() {}),
                  autofocus: true,
                ),
                const SizedBox(height: 30),
                const Text(
                  'Color',
                  style: TextStyle(
                    fontSize: 15, 
                    fontWeight: FontWeight.w500,
                    color: CupertinoColors.systemGrey
                  ),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 16,
                  runSpacing: 16,
                  children: _colors.map((colorHex) {
                    final color = Color(int.parse(colorHex.replaceAll('#', '0xFF')));
                    final isSelected = _selectedColor == colorHex;
                    return GestureDetector(
                      onTap: () => setState(() => _selectedColor = colorHex),
                      child: Container(
                        width: 44,
                        height: 44,
                        decoration: BoxDecoration(
                          color: color,
                          shape: BoxShape.circle,
                          border: isSelected 
                              ? Border.all(color: CupertinoColors.label, width: 3) // Dynamic border color
                              : null,
                        ),
                        child: isSelected 
                            ? const Icon(CupertinoIcons.checkmark, color: Colors.white, size: 20)
                            : null,
                      ),
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/view/home_page.dart home_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/extensions/app_localization.dart';
import '../../../core/application_state/logout_provider/logout_provider.dart';
import '../../../core/router/routes.dart';
import '../../../core/theme/theme.dart';
import '../../../core/widgets/loading_indicator.dart';

class HomePage extends ConsumerStatefulWidget {
  const HomePage({super.key});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage> {
  @override
  void initState() {
    super.initState();
    ref.listenManual(logoutProvider, (previous, next) {
      switch (next) {
        case AsyncData(:final value) when value == true:
          context.pushReplacementNamed(Routes.login);
        case AsyncError(:final error):
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text(error.toString())));
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(logoutProvider);

    return Scaffold(
      body: Padding(
        padding: EdgeInsets.all(context.padding.p16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(context.locale.home),
            Gap(context.spacing.s16),
            FilledButton(
              onPressed: () {
                ref.read(logoutProvider.notifier).call();
              },
              child: state.isLoading
                  ? const LoadingIndicator()
                  : Text(context.locale.logout),
            ),
          ],
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/pages/activities_management_page.dart activities_management_page.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors, ReorderableListView, DismissDirection;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/use_case_providers.dart';
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/presentation/core/widgets/tempo_design_system.dart';
import 'package:tempo/src/presentation/features/home/dialogs/activity_editor_dialog.dart';
import 'package:tempo/src/presentation/features/home/providers/activity_types_provider.dart';

class ActivitiesManagementPage extends ConsumerWidget {
  const ActivitiesManagementPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // We need to watch activityTypesProvider
    final activitiesAsync = ref.watch(activityTypesProvider);

    return CupertinoPageScaffold(
      backgroundColor: TempoDesign.background,
      navigationBar: CupertinoNavigationBar(
        middle: const Text('Manage Activities'),
        trailing: CupertinoButton(
          padding: EdgeInsets.zero,
          child: const Text('Done'),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ),
      child: SafeArea(
        child: activitiesAsync.when(
          data: (activities) {
             if (activities.isEmpty) {
                return const Center(child: Text('No activities'));
             }
             
             // ReorderableListView requires Material styling sometimes or custom proxy.
             // Standard ReorderableListView works in CupertinoApp but looks Material-ish?
             // Let's use it, wrapped in Material widget if needed (Scaffold body handles it usually).
             // Drag handles: Icons.drag_handle (Material). CupertinoIcons.bars?
             
             return ReorderableListView.builder(
               padding: const EdgeInsets.symmetric(vertical: 10),
               itemCount: activities.length,
               onReorder: (oldIndex, newIndex) {
                 if (oldIndex < newIndex) {
                   newIndex -= 1;
                 }
                 final item = activities.removeAt(oldIndex);
                 activities.insert(newIndex, item);
                 
                 // Update Repository
                 final ids = activities.map((e) => e.id).toList();
                 ref.read(reorderActivityTypesUseCaseProvider).call(ids);
               },
               itemBuilder: (context, index) {
                 final activity = activities[index];
                 final color = Color(int.parse(activity.color.replaceAll('#', '0xFF')));
                 
                 return _buildListItem(context, ref, activity, color);
               },
             );
          },
          loading: () => const Center(child: CupertinoActivityIndicator()),
          error: (_, __) => const Center(child: Text('Error')),
        ),
      ),
    );
  }

  Widget _buildListItem(BuildContext context, WidgetRef ref, ActivityType activity, Color color) {
    // Using Dismissible for delete
    return Dismissible(
      key: ValueKey(activity.id),
      direction: DismissDirection.endToStart,
      background: Container(
         color: CupertinoColors.destructiveRed,
         alignment: Alignment.centerRight,
         padding: const EdgeInsets.only(right: 20),
         child: const Icon(CupertinoIcons.delete, color: CupertinoColors.white),
      ),
      confirmDismiss: (direction) async {
         // Ask for confirmation? Or just delete?
         // Deleting activity might affect sessions. Repository handles validation?
         // Repository checks if used.
         try {
            await ref.read(deleteActivityTypeUseCaseProvider).call(activity.id);
            return true; // Dismiss if success
         } catch (e) {
            // Show error if failed (e.g. used)
            // Need context.
            showCupertinoDialog(
              context: context, 
              builder: (ctx) => CupertinoAlertDialog(
                title: const Text('Cannot Delete'),
                content: const Text('This activity is used in validation history or sessions.'),
                actions: [
                  CupertinoDialogAction(child: const Text('OK'), onPressed: () => Navigator.pop(ctx)),
                ],
              )
            );
            return false;
         }
      },
      child: Container(
        color: CupertinoColors.systemBackground, // White background for item
        child: CupertinoListTile( // Need to import or create custom? CupertinoListTile is available in updated Flutter.
           // However standard Flutter might not have CupertinoListTile in older versions?
           // SDK ^3.10.0 should have it. Can check.
           // If not, use standard Container + Row.
           // Let's assume Container + Row to be safe and "Soft UI"
           
           padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
           leading: Container(
             width: 24, 
             height: 24, 
             decoration: BoxDecoration(color: color, shape: BoxShape.circle)
           ),
           title: Text(activity.name, style: const TextStyle(fontSize: 17, color: TempoDesign.textPrimary)),
           trailing: const Icon(CupertinoIcons.bars, color: CupertinoColors.systemGrey3), // Drag handle visual
           onTap: () {
             // Edit
             showCupertinoModalPopup(
               context: context,
               builder: (context) => ActivityEditorDialog(activityToEdit: activity),
             );
           },
        ),
      ),
    );
  }
}

// Minimal CupertinoListTile fallback if not present (simpler to just inline Row)
class CupertinoListTile extends StatelessWidget {
  final Widget leading;
  final Widget title;
  final Widget trailing;
  final VoidCallback onTap;
  final EdgeInsetsGeometry padding;

  const CupertinoListTile({required this.leading, required this.title, required this.trailing, required this.onTap, required this.padding});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
       onTap: onTap,
       behavior: HitTestBehavior.opaque,
       child: Padding(
         padding: padding,
         child: Row(
           children: [
             leading,
             const SizedBox(width: 12),
             Expanded(child: title),
             trailing,
           ],
         ),
       ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/pages/home_page.dart home_page.dart
import 'dart:ui';
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cupertino_native/cupertino_native.dart';

import 'package:tempo/src/domain/entities/activity_type.dart';

import 'package:tempo/src/core/di/parts/use_case_providers.dart';
// import 'package:tempo/src/data/database/drift_database.dart'; // Removed to avoid conflict
import 'package:tempo/src/presentation/core/theme/theme_provider.dart';
import 'package:tempo/src/presentation/core/widgets/tempo_design_system.dart';
import 'package:tempo/src/presentation/features/home/providers/activity_types_provider.dart';
import 'package:tempo/src/presentation/features/home/providers/current_session_provider.dart';
import 'package:tempo/src/presentation/features/calendar/providers/session_list_provider.dart';
import 'package:tempo/src/presentation/features/home/providers/selected_activity_provider.dart';
import 'package:tempo/src/presentation/features/home/dialogs/activity_editor_dialog.dart';
import 'package:tempo/src/presentation/features/home/pages/activities_management_page.dart';

class HomePage extends ConsumerWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final today = DateTime.now();
    
    final sessionsAsync = ref.watch(sessionsForDayProvider(today));
    final activityTypesAsync = ref.watch(activityTypesProvider);
    final currentSessionAsync = ref.watch(currentSessionProvider);
    final elapsedTimeAsync = ref.watch(sessionElapsedTimeProvider);
    final themeMode = ref.watch(themeProvider);

    return CupertinoPageScaffold(
      backgroundColor: TempoDesign.background,
      navigationBar: CupertinoNavigationBar(
         middle: const Text('Tempo'),
         trailing: CNPopupMenuButton(
            buttonLabel: '',
            items: [
              const CNPopupMenuItem(label: 'Add Activity', icon: CNSymbol('plus')),
              const CNPopupMenuItem(label: 'Manage Activities', icon: CNSymbol('list.bullet')),
              const CNPopupMenuDivider(),
              CNPopupMenuItem(
                label: themeMode == AppThemeMode.light ? 'Dark Mode' : 'Light Mode', 
                icon: CNSymbol(themeMode == AppThemeMode.light ? 'moon.fill' : 'sun.max.fill')
              ),
            ],
            onSelected: (index) {
               if (index == 0) {
                  showCupertinoModalPopup(
                    context: context,
                    builder: (context) => const ActivityEditorDialog(),
                  );
               } else if (index == 1) {
                  showCupertinoModalPopup(
                    context: context,
                    builder: (context) => const ActivitiesManagementPage(),
                  );
               } else if (index == 3) { // 0=Add, 1=Manage, 2=Divider, 3=Theme
                  ref.read(themeProvider.notifier).toggle();
               }
            },
         ),
      ),
      child: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0),
          child: Column(
            children: [
              const SizedBox(height: 20),
              // Header
              Text(
                currentSessionAsync.value != null 
                    ? 'Active Session' 
                    : 'No active session',
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  color: TempoDesign.textSecondary,
                ),
              ),
              const SizedBox(height: 30),
              
              // Main Timer Card
              TempoCard(
                child: Column(
                  children: [
                    // Timer row
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            sessionsAsync.when(
                              data: (sessions) {
                                final total = sessions.fold(Duration.zero, (prev, s) {
                                  final dur = s.endAt?.difference(s.startAt) ?? Duration.zero;
                                  return prev + dur;
                                });
                                
                                return Text(
                                  'WH: ${_formatDuration(total)}',
                                  style: const TextStyle(
                                    fontSize: 16,
                                    color: TempoDesign.textSecondary,
                                    fontWeight: FontWeight.w500,
                                  ),
                                );
                              },
                              loading: () => const Text('WH: --:--', style: TextStyle(color: TempoDesign.textSecondary)),
                              error: (_, __) => const Text('WH: --:--', style: TextStyle(color: TempoDesign.textSecondary)),
                            ),
                            const SizedBox(height: 8),
                            // Progress bar placeholder
                            Container(
                              width: 100,
                              height: 4,
                              decoration: BoxDecoration(
                                color: const Color(0xFFE5E5EA),
                                borderRadius: BorderRadius.circular(2),
                              ),
                              child: FractionallySizedBox(
                                alignment: Alignment.centerLeft,
                                widthFactor: 0.6, // Placeholder
                                child: Container(
                                  decoration: BoxDecoration(
                                    color: const Color(0xFF5856D6),
                                    borderRadius: BorderRadius.circular(2),
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                        Text(
                          _formatDuration(elapsedTimeAsync ?? Duration.zero),
                          style: const TextStyle(
                            fontSize: 32,
                            fontWeight: FontWeight.bold,
                            fontFeatures: [FontFeature.tabularFigures()],
                            color: TempoDesign.textPrimary,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 24),
                    
                    // History List
                    Container(
                      constraints: const BoxConstraints(maxHeight: 200),
                      child: sessionsAsync.when(
                        data: (sessions) {
                          if (sessions.isEmpty) {
                            return const Center(child: Text('No sessions yet', style: TextStyle(color: TempoDesign.textSecondary)));
                          }
                          // Filter completed
                          final completed = sessions.where((s) => s.endAt != null).toList().reversed.toList();
                          
                          if (completed.isEmpty) {
                             return const Center(child: Text('No completed sessions', style: TextStyle(color: TempoDesign.textSecondary)));
                          }

                          return activityTypesAsync.when(
                             data: (types) {
                               final typeMap = {for (var t in types) t.id: t};
                               
                               return ListView.separated(
                                shrinkWrap: true,
                                physics: const ClampingScrollPhysics(),
                                itemCount: completed.length > 3 ? 3 : completed.length,
                                separatorBuilder: (_, __) => const SizedBox(height: 12),
                                itemBuilder: (context, index) {
                                  final s = completed[index];
                                  final duration = s.endAt!.difference(s.startAt);
                                  final type = typeMap[s.activityTypeId];
                                  final name = type?.name ?? s.note ?? 'Activity';
                                  final colorHex = type?.color ?? '#007AFF';
                                  final color = Color(int.parse(colorHex.replaceAll('#', '0xFF')));

                                  return _buildHistoryItem(
                                    name,
                                    _formatDuration(duration),
                                    color,
                                    true
                                  );
                                },
                              );
                             },
                             loading: () => const CupertinoActivityIndicator(),
                             error: (_, __) => const SizedBox.shrink(),
                          );
                        },
                        loading: () => const CupertinoActivityIndicator(),
                        error: (_, __) => const Text('Error loading history'),
                      ),
                    ),
                  ],
                ),
              ),
              
              const Spacer(),
              
              // Main Button
              TempoButton(
                isLarge: true,
                onPressed: () {
                   final session = currentSessionAsync.value;
                   if (session == null) {
                     _startSession(context, ref);
                   } else {
                     ref.read(stopSessionUseCaseProvider).call();
                   }
                },
                child: Text(
                  currentSessionAsync.value != null ? 'Stop' : 'Start',
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w600,
                    color: TempoDesign.textPrimary,
                    letterSpacing: 0.5,
                  ),
                ),
              ),
              
              const SizedBox(height: 40),
              
              // Activity Selector (Scrollable Segmented Control)
              SizedBox(
                 height: 40,
                 child: activityTypesAsync.when(
                    data: (types) {
                      if (types.isEmpty) return const SizedBox.shrink();
                      return _ActivitySelector(types: types);
                    },
                    loading: () => const CupertinoActivityIndicator(),
                    error: (_, __) => const SizedBox.shrink(),
                 ),
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHistoryItem(String name, String time, Color color, bool isDone) {
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(4),
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: color, 
          ),
          child: const Icon(CupertinoIcons.checkmark, size: 10, color: CupertinoColors.white),
        ),
        const SizedBox(width: 12),
        Text(
          name,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: TempoDesign.textPrimary,
          ),
        ),
        const Spacer(),
        Text(
          time,
          style: const TextStyle(
            fontSize: 16,
            color: TempoDesign.textSecondary,
            fontFamily: 'Courier', 
          ),
        ),
        const SizedBox(width: 8),
        const Icon(CupertinoIcons.chevron_right, size: 14, color: TempoDesign.textSecondary),
      ],
    );
  }

  String _formatDuration(Duration d) {
    if (d.inMilliseconds == 0) return '00:00';
    final hours = d.inHours.toString().padLeft(2, '0');
    final minutes = (d.inMinutes % 60).toString().padLeft(2, '0');
    final seconds = (d.inSeconds % 60).toString().padLeft(2, '0');
    if (d.inHours > 0) {
      return '$hours:$minutes:$seconds';
    }
    return '$minutes:$seconds';
  }
  
  void _startSession(BuildContext context, WidgetRef ref) {
     final selectedId = ref.read(selectedActivityIdProvider);
     if (selectedId != null) {
        ref.read(startSessionUseCaseProvider).call(selectedId);
     } else {
        // Fallback to first if not selected?
        final activityTypes = ref.read(activityTypesProvider).value;
        if (activityTypes != null && activityTypes.isNotEmpty) {
           ref.read(startSessionUseCaseProvider).call(activityTypes.first.id);
        }
     }
  }
}

class _ActivitySelector extends ConsumerStatefulWidget {
   final List<ActivityType> types;
   const _ActivitySelector({required this.types});
   
   @override
   ConsumerState<_ActivitySelector> createState() => _ActivitySelectorState();
}

class _ActivitySelectorState extends ConsumerState<_ActivitySelector> {
   String? _selectedId;

   @override
   void initState() {
     super.initState();
     if (widget.types.isNotEmpty) {
       _selectedId = widget.types.first.id;
        // Initialize global provider too?
        // Better to check if global is null, then set it.
        WidgetsBinding.instance.addPostFrameCallback((_) {
           if (ref.read(selectedActivityIdProvider) == null) {
              ref.read(selectedActivityIdProvider.notifier).state = widget.types.first.id;
              setState(() => _selectedId = widget.types.first.id);
           } else {
              setState(() => _selectedId = ref.read(selectedActivityIdProvider));
           }
        });
     }
   }

   @override
   Widget build(BuildContext context) {
      final map = <String, Widget>{};
      for (var t in widget.types) {
         map[t.id] = Padding(
           padding: const EdgeInsets.symmetric(horizontal: 16),
           child: Text(t.name),
         );
      }

      return SingleChildScrollView(
         scrollDirection: Axis.horizontal,
         child: CupertinoSlidingSegmentedControl<String>(
            groupValue: _selectedId,
            children: map,
            onValueChanged: (val) {
               if (val != null) {
                 setState(() => _selectedId = val);
                 ref.read(selectedActivityIdProvider.notifier).state = val;
               }
            },
         ),
      );
   }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/widgets/activity_selector.dart activity_selector.dart
import 'package:flutter/material.dart';
import 'package:gap/gap.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/domain/entities/activity_type.dart';

/// Селектор активностей для быстрого старта/переключения
class ActivitySelector extends StatelessWidget {
  final List<ActivityType> activityTypes;
  final Function(ActivityType) onActivitySelected;

  const ActivitySelector({
    super.key,
    required this.activityTypes,
    required this.onActivitySelected,
  });

  @override
  Widget build(BuildContext context) {
    // Отфильтровать скрытые
    final visibleTypes = activityTypes.where((a) => !a.isHidden).toList();

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: visibleTypes.map((activityType) {
        return _ActivityChip(
          activityType: activityType,
          onTap: () => onActivitySelected(activityType),
        );
      }).toList(),
    );
  }
}

class _ActivityChip extends StatelessWidget {
  final ActivityType activityType;
  final VoidCallback onTap;

  const _ActivityChip({
    required this.activityType,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final color = Color(
      int.parse(activityType.color.substring(1), radix: 16) + 0xFF000000,
    );

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        decoration: BoxDecoration(
          color: color.withOpacity(0.15),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: color, width: 1.5),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 8,
              height: 8,
              decoration: BoxDecoration(
                color: color,
                shape: BoxShape.circle,
              ),
            ),
            const Gap(8),
            Text(
              activityType.name,
              style: TextStyle(
                color: color,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/widgets/active_session_card.dart active_session_card.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:gap/gap.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/presentation/features/home/providers/activity_types_provider.dart';
import 'package:tempo/src/presentation/features/home/providers/current_session_provider.dart';

/// Карточка отображения активной сессии
class ActiveSessionCard extends ConsumerWidget {
  final Session? session;

  const ActiveSessionCard({
    super.key,
    required this.session,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (session == null) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            children: [
              Icon(
                Icons.timer_off_outlined,
                size: 48,
                color: Colors.grey.shade400,
              ),
              const Gap(8),
              Text(
                'No active session',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  color: Colors.grey.shade600,
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Получить информацию о типе активности
    final activityTypesAsync = ref.watch(activityTypesProvider);
    final elapsedTimeAsync = ref.watch(sessionElapsedTimeProvider);

    return Card(
      color: Theme.of(context).colorScheme.primaryContainer,
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Название активности
            activityTypesAsync.whenData((activityTypes) {
              final typeId = session!.activityTypeId;
              final activityType = activityTypes.firstWhere(
                (a) => a.id == typeId,
                orElse: () => activityTypes.first,
              );
              
              return Row(
                children: [
                  Container(
                    width: 12,
                    height: 12,
                    decoration: BoxDecoration(
                      color: Color(
                        int.parse(activityType.color.substring(1), radix: 16) +
                            0xFF000000,
                      ),
                      shape: BoxShape.circle,
                    ),
                  ),
                  const Gap(8),
                  Text(
                    activityType.name,
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              );
            }).value ?? const SizedBox.shrink(),
            
            const Gap(12),
            
            // Elapsed time
            elapsedTimeAsync.when(
              data: (duration) {
                if (duration == null) return const SizedBox.shrink();
                
                final hours = duration.inHours;
                final minutes = duration.inMinutes.remainder(60);
                final seconds = duration.inSeconds.remainder(60);
                
                return Text(
                  '${hours.toString().padLeft(2, '0')}:'
                  '${minutes.toString().padLeft(2, '0')}:'
                  '${seconds.toString().padLeft(2, '0')}',
                  style: Theme.of(context).textTheme.displaySmall?.copyWith(
                    fontWeight: FontWeight.w300,
                    fontFeatures: [const FontFeature.tabularFigures()],
                  ),
                );
              },
              loading: () => const Text('--:--:--'),
              error: (_, __) => const Text('--:--:--'),
            ),
          ],
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/providers/selected_activity_provider.dart selected_activity_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

final selectedActivityIdProvider = StateProvider<String?>((ref) => null);


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/providers/activity_types_provider.dart activity_types_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/repository_providers.dart';
import 'package:tempo/src/domain/entities/activity_type.dart';

/// Provider для списка типов активности
final activityTypesProvider = StreamProvider<List<ActivityType>>((ref) {
  final repository = ref.watch(activityTypeRepositoryProvider);
  return repository.watchActivityTypes();
});



================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/home/providers/current_session_provider.dart current_session_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/repository_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;

/// Provider для активной сессии (Stream)
final currentSessionProvider = StreamProvider<Session?>((ref) {
  final repository = ref.watch(sessionRepositoryProvider);
  return repository.watchActiveSession();
});

/// Тикер, обновляющийся каждую секунду
final tickerProvider = StreamProvider<int>((ref) {
  return Stream.periodic(const Duration(seconds: 1), (x) => x);
});

/// Provider для elapsed time активной сессии
final sessionElapsedTimeProvider = Provider<Duration?>((ref) {
  final sessionAsync = ref.watch(currentSessionProvider);
  // Подписываемся на тикер для обновления каждую секунду
  ref.watch(tickerProvider);
  
  return sessionAsync.when(
    data: (session) {
      if (session == null) return null;
      return DateTime.now().difference(session.startAt);
    },
    loading: () => null,
    error: (_, __) => null,
  );
});



================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/splash/view/splash_page.dart splash_page.dart
import 'package:flutter/material.dart';

import '../../../core/theme/theme.dart';

class SplashPage extends StatelessWidget {
  const SplashPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: context.color.onPrimary,
      body: Center(child: FlutterLogo(size: context.spacing.s210)),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/tasks/dialogs/task_editor_dialog.dart task_editor_dialog.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:tempo/src/core/di/parts/use_case_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/data/models/task_extensions.dart';
import 'package:tempo/src/domain/entities/repeat_rule.dart';
import 'package:tempo/src/presentation/features/tasks/widgets/repeat_rule_selector.dart';

class TaskEditorDialog extends ConsumerStatefulWidget {
  final Task? task;

  const TaskEditorDialog({super.key, this.task});

  @override
  ConsumerState<TaskEditorDialog> createState() => _TaskEditorDialogState();
}

class _TaskEditorDialogState extends ConsumerState<TaskEditorDialog> {
  late TextEditingController _titleController;
  DateTime? _deadline;
  RepeatRule? _repeatRule;

  @override
  void initState() {
    super.initState();
    _titleController = TextEditingController(text: widget.task?.title ?? '');
    _deadline = widget.task?.deadline;
    _repeatRule = widget.task?.repeatRule;
  }

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }

  Future<void> _selectDate() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: _deadline ?? now,
      firstDate: now.subtract(const Duration(days: 365)),
      lastDate: now.add(const Duration(days: 365 * 5)),
    );
    if (picked != null) {
      setState(() {
        _deadline = picked;
      });
    }
  }

  void _save() {
    final title = _titleController.text.trim();
    if (title.isEmpty) return;

    if (widget.task == null) {
      // Create
      ref.read(createTaskUseCaseProvider).call(
        title: title,
        deadline: _deadline,
        repeatRule: _repeatRule,
      );
    } else {
      // Update - пока нет use case, добавим позже или используем repo напрямую
      // ref.read(updateTaskUseCaseProvider).call(...)
      // Для MVP пока только создание
    }
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(widget.task == null ? 'New Task' : 'Edit Task'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _titleController,
            decoration: const InputDecoration(
              labelText: 'Title',
              hintText: 'What needs to be done?',
            ),
            autofocus: true,
            textCapitalization: TextCapitalization.sentences,
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              TextButton.icon(
                onPressed: _selectDate,
                icon: const Icon(Icons.calendar_today),
                label: Text(_deadline == null
                    ? 'No Deadline'
                    : DateFormat.yMMMd().format(_deadline!)),
              ),
              const Spacer(),
              if (_deadline != null)
                IconButton(
                  onPressed: () => setState(() => _deadline = null),
                  icon: const Icon(Icons.close),
                ),
            ],
          ),
          const SizedBox(height: 16),
          RepeatRuleSelector(
            value: _repeatRule,
            onChanged: (rule) => setState(() => _repeatRule = rule),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        FilledButton(
          onPressed: _save,
          child: const Text('Save'),
        ),
      ],
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/tasks/pages/tasks_page.dart tasks_page.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors; // For minimal fallbacks
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/presentation/core/widgets/tempo_design_system.dart';
import 'package:tempo/src/presentation/features/tasks/dialogs/task_editor_dialog.dart';
import 'package:tempo/src/presentation/features/tasks/widgets/task_list_widget.dart';

class TasksPage extends ConsumerStatefulWidget {
  const TasksPage({super.key});

  @override
  ConsumerState<TasksPage> createState() => _TasksPageState();
}

class _TasksPageState extends ConsumerState<TasksPage> {
  int _selectedSegment = 0; // 0: Active, 1: Done

  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      backgroundColor: TempoDesign.background,
      navigationBar: CupertinoNavigationBar(
        middle: const Text('Tasks'),
        trailing: CupertinoButton(
           padding: EdgeInsets.zero,
           child: const Icon(CupertinoIcons.add),
           onPressed: () => _showAddDialog(context),
        ),
      ),
      child: SafeArea(
        child: Column(
          children: [
            const SizedBox(height: 16),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: SizedBox(
                width: double.infinity,
                child: CupertinoSlidingSegmentedControl<int>(
                  groupValue: _selectedSegment,
                  children: const {
                    0: Padding(padding: EdgeInsets.symmetric(horizontal: 20), child: Text('Active')),
                    1: Padding(padding: EdgeInsets.symmetric(horizontal: 20), child: Text('Done')),
                  },
                  onValueChanged: (value) {
                    if (value != null) {
                      setState(() => _selectedSegment = value);
                    }
                  },
                ),
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: IndexedStack(
                index: _selectedSegment,
                children: const [
                  TaskListWidget(status: TaskStatus.active),
                  TaskListWidget(status: TaskStatus.done),
                ],
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: TempoButton(
                onPressed: () => _showAddDialog(context),
                child: const Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(CupertinoIcons.add, color: TempoDesign.textPrimary, size: 20),
                    SizedBox(width: 8),
                    Text(
                      'Add new task',
                      style: TextStyle(
                        fontSize: 17,
                        fontWeight: FontWeight.w600,
                        color: TempoDesign.textPrimary,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showAddDialog(BuildContext context) {
    showCupertinoModalPopup(
      context: context,
      builder: (context) => const TaskEditorDialog(),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/tasks/widgets/repeat_rule_selector.dart repeat_rule_selector.dart
import 'package:flutter/material.dart';
import 'package:tempo/src/domain/entities/repeat_rule.dart';

class RepeatRuleSelector extends StatelessWidget {
  final RepeatRule? value;
  final ValueChanged<RepeatRule?> onChanged;

  const RepeatRuleSelector({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<String>(
      decoration: const InputDecoration(
        labelText: 'Repeat',
        prefixIcon: Icon(Icons.repeat),
      ),
      value: _getPresetKey(value),
      items: const [
        DropdownMenuItem(value: 'none', child: Text('No Repeat')),
        DropdownMenuItem(value: 'daily', child: Text('Every Day')),
        DropdownMenuItem(value: 'weekly', child: Text('Every Week')),
        DropdownMenuItem(value: 'workdays', child: Text('Every Workday')),
        DropdownMenuItem(value: 'custom', child: Text('Custom... (Not implemented)')),
      ],
      onChanged: (key) {
        if (key == null) return;
        
        switch (key) {
          case 'none':
            onChanged(null);
            break;
          case 'daily':
            onChanged(const FixedScheduleRepeat({1, 2, 3, 4, 5, 6, 7}));
            break;
          case 'weekly':
            // Текущий день недели
            final now = DateTime.now();
            onChanged(FixedScheduleRepeat({now.weekday}));
            break;
          case 'workdays':
            onChanged(const FixedScheduleRepeat({1, 2, 3, 4, 5}));
            break;
          case 'custom':
            // TODO: Open custom dialog
            break;
        }
      },
    );
  }

  String _getPresetKey(RepeatRule? rule) {
    if (rule == null) return 'none';
    
    if (rule is FixedScheduleRepeat) {
      if (rule.weekdays.length == 7) return 'daily';
      if (rule.weekdays.length == 5 && 
          rule.weekdays.containsAll({1, 2, 3, 4, 5})) return 'workdays';
      if (rule.weekdays.length == 1) return 'weekly';
    }
    
    return 'custom';
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/tasks/widgets/task_list_widget.dart task_list_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/presentation/features/tasks/providers/tasks_provider.dart';
import 'package:tempo/src/presentation/features/tasks/widgets/task_card_widget.dart';

class TaskListWidget extends ConsumerWidget {
  final TaskStatus status;

  const TaskListWidget({super.key, required this.status});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final tasksAsync = ref.watch(tasksByStatusProvider(status));

    return tasksAsync.when(
      data: (tasks) {
        if (tasks.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  status == TaskStatus.done
                      ? Icons.task_alt
                      : Icons.checklist,
                  size: 64,
                  color: Theme.of(context).colorScheme.outlineVariant,
                ),
                const SizedBox(height: 16),
                Text(
                  status == TaskStatus.done
                      ? 'No completed tasks yet'
                      : 'No active tasks',
                  style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                        color: Theme.of(context).colorScheme.outline,
                      ),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          padding: const EdgeInsets.symmetric(vertical: 16),
          itemCount: tasks.length,
          itemBuilder: (context, index) {
            final task = tasks[index];
            return TaskCardWidget(task: task);
          },
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (err, stack) => Center(child: Text('Error: $err')),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/tasks/widgets/task_card_widget.dart task_card_widget.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors, Icons, Dismissible, DismissDirection, ValueKey; // Use minimal material
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:tempo/src/core/di/parts/use_case_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/data/models/task_extensions.dart';
import 'package:tempo/src/presentation/core/widgets/tempo_design_system.dart';

class TaskCardWidget extends ConsumerWidget {
  final Task task;

  const TaskCardWidget({super.key, required this.task});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isDone = task.status == TaskStatus.done;

    return Dismissible(
      key: ValueKey(task.id),
      background: Container(
        color: CupertinoColors.destructiveRed,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 16),
        child: const Icon(CupertinoIcons.delete, color: CupertinoColors.white),
      ),
      direction: DismissDirection.endToStart,
      onDismissed: (direction) {
         // TODO: Implement delete
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
        child: TempoCard(
          padding: EdgeInsets.zero,
          child: CupertinoButton(
            padding: const EdgeInsets.all(16),
            onPressed: () {
              // TODO: Open edit dialog
            },
            child: Row(
              children: [
                // Checkbox
                GestureDetector(
                  onTap: () {
                    if (!isDone) {
                       ref.read(completeTaskUseCaseProvider).call(task.id);
                    }
                  },
                  child: Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: isDone 
                            ? CupertinoColors.activeBlue 
                            : CupertinoColors.systemGrey4,
                        width: 2,
                      ),
                      color: isDone ? CupertinoColors.activeBlue : Colors.transparent,
                    ),
                    child: isDone 
                        ? const Icon(CupertinoIcons.checkmark, size: 16, color: CupertinoColors.white) 
                        : null,
                  ),
                ),
                const SizedBox(width: 16),
                // Content
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        task.title,
                        style: TextStyle(
                          fontSize: 16,
                          decoration: isDone ? TextDecoration.lineThrough : null,
                          color: isDone 
                              ? TempoDesign.textSecondary 
                              : TempoDesign.textPrimary,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      if (task.deadline != null || task.repeatRule != null) ...[
                        const SizedBox(height: 8),
                        Row(
                          children: [
                            if (task.deadline != null) ...[
                              _buildDateBadge(task.deadline!),
                              const SizedBox(width: 8),
                            ],
                            if (task.repeatRule != null)
                              const TempoBadge(
                                text: 'Repeats',
                                color: CupertinoColors.systemIndigo,
                              ),
                          ],
                        ),
                      ],
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDateBadge(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final taskDate = DateTime(date.year, date.month, date.day);
    
    final isOverdue = taskDate.isBefore(today);
    final isToday = taskDate.isAtSameMomentAs(today);
    final isTomorrow = taskDate.isAtSameMomentAs(today.add(const Duration(days: 1)));
    
    Color color = CupertinoColors.systemGrey;
    String text = DateFormat.MMMd().format(date);
    
    if (isOverdue) {
      color = CupertinoColors.destructiveRed;
      text = 'Overdue';
    } else if (isToday) {
      color = CupertinoColors.activeOrange;
      text = 'Due Today';
    } else if (isTomorrow) {
      color = CupertinoColors.activeOrange;
      text = 'Due Tomorrow';
    }

    return TempoBadge(text: text, color: color);
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/tasks/providers/tasks_provider.dart tasks_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/repository_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;

/// Provider для списка задач с фильтрацией по статусу
final tasksByStatusProvider = StreamProvider.family<List<Task>, TaskStatus?>((ref, status) {
  final repository = ref.watch(taskRepositoryProvider);
  return repository.watchTasksByStatus(status);
});

/// Provider для всех задач (без фильтра)
final allTasksProvider = StreamProvider<List<Task>>((ref) {
  final repository = ref.watch(taskRepositoryProvider);
  return repository.watchTasksByStatus(null);
});


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/profile/view/profile_page.dart profile_page.dart
import 'package:flutter/material.dart';

class ProfilePage extends StatefulWidget {
  const ProfilePage({super.key});

  @override
  State<ProfilePage> createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  @override
  Widget build(BuildContext context) {
    return const Placeholder();
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/dialogs/manual_session_editor.dart manual_session_editor.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors; // For debugging/fallback
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:tempo/src/core/di/parts/use_case_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/domain/entities/conflict_resolution.dart';
import 'package:tempo/src/presentation/features/home/providers/activity_types_provider.dart';

class ManualSessionEditor extends ConsumerStatefulWidget {
  final DateTime initialDate;

  const ManualSessionEditor({super.key, required this.initialDate});

  @override
  ConsumerState<ManualSessionEditor> createState() => _ManualSessionEditorState();
}

class _ManualSessionEditorState extends ConsumerState<ManualSessionEditor> {
  ActivityType? _selectedActivityType;
  late DateTime _startAt;
  late DateTime _endAt;
  late TextEditingController _noteController;

  @override
  void initState() {
    super.initState();
    // Default start: 9:00 AM on selected day
    final date = widget.initialDate;
    _startAt = DateTime(date.year, date.month, date.day, 9, 0);
    _endAt = _startAt.add(const Duration(hours: 1));
    _noteController = TextEditingController();
  }

  @override
  void dispose() {
    _noteController.dispose();
    super.dispose();
  }

  void _save() async {
    if (_selectedActivityType == null) return;
    
    // Check constraints
    if (_endAt.isBefore(_startAt)) {
      // Show error
      showCupertinoDialog(
        context: context,
        builder: (context) => CupertinoAlertDialog(
          title: const Text('Invalid Time'),
          content: const Text('End time must be after start time.'),
          actions: [CupertinoDialogAction(child: const Text('OK'), onPressed: () => Navigator.pop(context))],
        ),
      );
      return;
    }

    final addSessionUseCase = ref.read(addManualSessionUseCaseProvider);
    
    final result = await addSessionUseCase.call(
      activityTypeId: _selectedActivityType!.id,
      startAt: _startAt,
      endAt: _endAt,
      note: _noteController.text.isEmpty ? null : _noteController.text,
    );

    if (result.isSuccess) {
      Navigator.of(context).pop();
    } else {
      // Conflicts
      _showConflictDialog(result.conflicts);
    }
  }
  
  void _showConflictDialog(List<SessionConflict> conflicts) {
    // Simplified conflict resolution for MVP: default to Trim
    // In full version, show options
    showCupertinoDialog(
      context: context,
      builder: (context) => CupertinoAlertDialog(
        title: const Text('Conflict Detected'),
        content: Text('This session overlaps with ${conflicts.length} existing session(s). Adjust automatically?'),
        actions: [
          CupertinoDialogAction(
            isDestructiveAction: true,
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          CupertinoDialogAction(
            isDefaultAction: true,
            onPressed: () {
               // TODO: Call resolve conflict
               Navigator.pop(context);
               Navigator.pop(context); // Close editor
            },
            child: const Text('Overall (Trim/Split)'),
          ),
        ],
      ),
    );
  }

  void _showActivityPicker(List<ActivityType> types) {
    showCupertinoModalPopup(
      context: context,
      builder: (context) => Container(
        height: 250,
        color: CupertinoColors.systemBackground.resolveFrom(context),
        child: Column(
          children: [
             Row(
               mainAxisAlignment: MainAxisAlignment.end,
               children: [
                 CupertinoButton(
                   child: const Text('Done'),
                   onPressed: () => Navigator.pop(context),
                 ),
               ],
             ),
             Expanded(
               child: CupertinoPicker(
                 itemExtent: 32,
                 onSelectedItemChanged: (index) {
                   setState(() {
                     _selectedActivityType = types[index];
                   });
                 },
                 children: types.map((t) => Text(t.name)).toList(),
               ),
             ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final activityTypesAsync = ref.watch(activityTypesProvider);
    
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: const Text('New Session'),
        leading: CupertinoButton(
          padding: EdgeInsets.zero,
          child: const Text('Cancel'),
          onPressed: () => Navigator.of(context).pop(),
        ),
        trailing: CupertinoButton(
          padding: EdgeInsets.zero,
          onPressed: _selectedActivityType == null ? null : _save,
          child: const Text('Add'),
        ),
      ),
      child: SafeArea(
        child: activityTypesAsync.when(
          data: (types) {
             if (_selectedActivityType == null && types.isNotEmpty) {
               // Auto-select first in next frame or here? 
               // Better avoid setState in build. Initialized with null is fine.
             }
             
             return ListView(
               children: [
                 CupertinoFormSection.insetGrouped(
                   header: const Text('Activity'),
                   children: [
                     CupertinoFormRow(
                       prefix: const Text('Type'),
                       child: CupertinoButton(
                         padding: EdgeInsets.zero,
                         onPressed: () => _showActivityPicker(types),
                         child: Text(
                           _selectedActivityType?.name ?? 'Select Activity',
                           style: TextStyle(
                             color: _selectedActivityType == null 
                               ? CupertinoColors.placeholderText 
                               : CupertinoColors.label,
                           ),
                         ),
                       ),
                     ),
                   ],
                 ),
                 
                 CupertinoFormSection.insetGrouped(
                   header: const Text('Time'),
                   children: [
                     _buildDatePickerRow('Start', _startAt, (date) => setState(() => _startAt = date)),
                     _buildDatePickerRow('End', _endAt, (date) => setState(() => _endAt = date)),
                   ],
                 ),
                 
                 CupertinoFormSection.insetGrouped(
                   header: const Text('Note'),
                   children: [
                     CupertinoTextFormFieldRow(
                       controller: _noteController,
                       placeholder: 'Add a note',
                       maxLines: 3,
                     ),
                   ],
                 ),
               ],
             );
          },
          loading: () => const Center(child: CupertinoActivityIndicator()),
          error: (err, _) => Center(child: Text('Error: $err')),
        ),
      ),
    );
  }
  
  Widget _buildDatePickerRow(String label, DateTime value, ValueChanged<DateTime> onChanged) {
    return CupertinoFormRow(
      prefix: Text(label),
      child: CupertinoButton(
        padding: EdgeInsets.zero,
        onPressed: () {
           showCupertinoModalPopup(
             context: context,
             builder: (context) => Container(
               height: 250,
               color: CupertinoColors.systemBackground.resolveFrom(context),
               child: Column(
                 children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        CupertinoButton(
                          child: const Text('Done'),
                          onPressed: () => Navigator.pop(context),
                        )
                      ],
                    ),
                    Expanded(
                      child: CupertinoDatePicker(
                        mode: CupertinoDatePickerMode.dateAndTime,
                        initialDateTime: value,
                        onDateTimeChanged: onChanged,
                        use24hFormat: true,
                      ),
                    ),
                 ],
               ),
             ),
           );
        },
        child: Text(
          DateFormat('MMM d, HH:mm').format(value),
          style: const TextStyle(color: CupertinoColors.label),
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/pages/calendar_page.dart calendar_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/presentation/features/calendar/providers/calendar_view_state.dart';
import 'package:tempo/src/presentation/features/calendar/providers/session_list_provider.dart';
import 'package:tempo/src/presentation/features/calendar/widgets/day_timeline_widget.dart';
import 'package:flutter/cupertino.dart';
import 'package:tempo/src/presentation/features/calendar/dialogs/manual_session_editor.dart';
import 'package:tempo/src/presentation/features/calendar/widgets/weekly_heatmap_widget.dart';
import 'package:tempo/src/presentation/features/home/providers/activity_types_provider.dart';

class CalendarPage extends ConsumerWidget {
  const CalendarPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedDate = ref.watch(selectedDateProvider);
    final sessionsAsync = ref.watch(sessionsForDayProvider(selectedDate));
    final activityTypesAsync = ref.watch(activityTypesProvider);

    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: GestureDetector(
          onTap: () => _showDatePicker(context, ref, selectedDate),
          child: Text(DateFormat.yMMMMd().format(selectedDate)),
        ),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            CupertinoButton(
              padding: EdgeInsets.zero,
              onPressed: () => ref.read(selectedDateProvider.notifier).state = DateTime.now(),
              child: const Icon(CupertinoIcons.today),
            ),
            CupertinoButton(
              padding: EdgeInsets.zero,
              onPressed: () {
                showCupertinoModalPopup(
                  context: context,
                  builder: (context) => ManualSessionEditor(initialDate: selectedDate),
                );
              },
              child: const Icon(CupertinoIcons.add),
            ),
          ],
        ),
      ),
      child: SafeArea(
        child: Column(
          children: [
            const WeeklyHeatmapWidget(),
            Expanded(
              child: activityTypesAsync.when(
                data: (activityTypes) {
                   final activityTypeMap = {
                     for (var type in activityTypes) type.id: type
                   };
                   
                   return sessionsAsync.when(
                     data: (sessions) {
                       return DayTimelineWidget(
                         sessions: sessions,
                         activityTypeMap: activityTypeMap,
                       );
                     },
                     loading: () => const Center(child: CupertinoActivityIndicator()),
                     error: (err, stack) => Center(child: Text('Error: $err')),
                   );
                },
                loading: () => const Center(child: CupertinoActivityIndicator()),
                error: (err, stack) => Center(child: Text('Error: $err')),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showDatePicker(BuildContext context, WidgetRef ref, DateTime initialDate) {
    showCupertinoModalPopup(
      context: context,
      builder: (context) => Container(
        height: 250,
        color: CupertinoColors.systemBackground.resolveFrom(context),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                 CupertinoButton(
                   child: const Text('Done'),
                   onPressed: () => Navigator.pop(context),
                 ),
              ],
            ),
            Expanded(
              child: CupertinoDatePicker(
                mode: CupertinoDatePickerMode.date,
                initialDateTime: initialDate,
                onDateTimeChanged: (val) {
                  ref.read(selectedDateProvider.notifier).state = val;
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/widgets/day_timeline_widget.dart day_timeline_widget.dart
import 'package:flutter/material.dart';
import 'package:tempo/src/data/database/drift_database.dart';
import 'package:tempo/src/presentation/features/calendar/widgets/session_segment_widget.dart';

class DayTimelineWidget extends StatelessWidget {
  final List<Session> sessions;
  final Map<String, ActivityType> activityTypeMap;
  final double hourHeight;

  const DayTimelineWidget({
    super.key,
    required this.sessions,
    required this.activityTypeMap,
    this.hourHeight = 60.0,
  });

  @override
  Widget build(BuildContext context) {
    // Высота 24 часов
    final totalHeight = hourHeight * 24;

    return SingleChildScrollView(
      child: Container(
        height: totalHeight,
        color: Theme.of(context).scaffoldBackgroundColor,
        child: Stack(
          children: [
            // Background grid (hours)
            ...List.generate(24, (index) {
              return Positioned(
                top: index * hourHeight,
                left: 0,
                right: 0,
                child: Container(
                  height: hourHeight,
                  decoration: BoxDecoration(
                    border: Border(
                      top: BorderSide(
                        color: Theme.of(context).dividerColor.withOpacity(0.5),
                        width: 0.5,
                      ),
                    ),
                  ),
                  child: Align(
                    alignment: Alignment.topLeft,
                    child: Padding(
                      padding: const EdgeInsets.only(left: 8, top: 4),
                      child: Text(
                        '${index.toString().padLeft(2, '0')}:00',
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                              color: Theme.of(context).disabledColor,
                            ),
                      ),
                    ),
                  ),
                ),
              );
            }),

            // Sessions
            ...sessions.map((session) {
              final type = activityTypeMap[session.activityTypeId];
              if (type == null) return const SizedBox.shrink();

              // Calculate position
              final startMinutes = session.startAt.hour * 60 + session.startAt.minute;
              
              // Если сессия активна (endAt == null), считаем до текущего момента или конца дня
              final end = session.endAt ?? DateTime.now();
              // Отрезаем, если сессия выходит за границы дня (визуализация только для одного дня)
              // (Для MVP упрощаем: если сессия началась вчера, startAt будет вчера, и top < 0, это скроет её начало)
              // Нам нужно правильно считать высоту и top относительно начала этого дня.
              
              // Для корректности: нужно обрезать start и end по границам текущего дня (00:00 - 24:00)
              // Но provider уже фильтрует сессии, которые пересекаются с этим днем.
              
              final startOfDay = DateTime(session.startAt.year, session.startAt.month, session.startAt.day); 
              // ВНИМАНИЕ: session.startAt может быть в другой день, если provider вернул сессию, начавшуюся вчера и закончившуюся сегодня.
              // Но в простом случае (без cross-day logic сложно) пока считаем, что startAt.hour берется "как есть", 
              // что может быть ошибкой для cross-day.
              
              // Упрощение для MVP: используем startMinutes как есть. Cross-day позже.
              
              double top = (startMinutes / 60) * hourHeight;
              
              int durationMinutes;
              if (session.endAt == null) {
                // Active session
                final now = DateTime.now();
                durationMinutes = now.difference(session.startAt).inMinutes;
              } else {
                durationMinutes = session.endAt!.difference(session.startAt).inMinutes;
              }
              
              double height = (durationMinutes / 60) * hourHeight;
              
              return Positioned(
                top: top,
                left: 50, // Отступ для времени
                right: 0,
                height: height < 1 ? 1 : height, // Минимальная высота
                child: SessionSegmentWidget(
                  session: session,
                  activityType: type,
                  height: height,
                  width: double.infinity,
                ),
              );
            }),
            
            // Current time indicator (line)
            _buildCurrentTimeIndicator(context),
          ],
        ),
      ),
    );
  }
  
  Widget _buildCurrentTimeIndicator(BuildContext context) {
    final now = DateTime.now();
    final minutes = now.hour * 60 + now.minute;
    final top = (minutes / 60) * hourHeight;
    
    return Positioned(
       top: top,
       left: 0,
       right: 0,
       child: Divider(color: Colors.red, thickness: 1, height: 1),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/widgets/session_segment_widget.dart session_segment_widget.dart
import 'package:flutter/material.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;
import 'package:tempo/src/domain/entities/activity_type.dart';
import 'package:tempo/src/presentation/core/theme/tempo_colors.dart'; // Надо будет создать или использовать hardcoded цвета пока

class SessionSegmentWidget extends StatelessWidget {
  final Session session;
  final ActivityType activityType;
  final double height;
  final double width;

  const SessionSegmentWidget({
    super.key,
    required this.session,
    required this.activityType,
    required this.height,
    required this.width,
  });

  @override
  Widget build(BuildContext context) {
    // Делаем цвет немного прозрачным для фона
    final color = Color(int.parse(activityType.color.replaceAll('#', '0xFF')));
    
    return Container(
      height: height,
      width: width,
      margin: const EdgeInsets.symmetric(horizontal: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.3),
        border: Border(
          left: BorderSide(color: color, width: 4),
        ),
        borderRadius: BorderRadius.circular(4),
      ),
      padding: const EdgeInsets.only(left: 8, top: 4, right: 4),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            activityType.name,
            style: Theme.of(context).textTheme.labelSmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: color,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          if (height > 30)
            Text(
              session.note ?? '',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(fontSize: 10),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
        ],
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/widgets/weekly_heatmap_widget.dart weekly_heatmap_widget.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors; // Fallback
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:tempo/src/presentation/features/calendar/providers/calendar_view_state.dart';
import 'package:tempo/src/presentation/features/calendar/providers/weekly_stats_provider.dart';

class WeeklyHeatmapWidget extends ConsumerWidget {
  const WeeklyHeatmapWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedDate = ref.watch(selectedDateProvider);
    final statsAsync = ref.watch(weeklyActivityStatsProvider(selectedDate));
    final weekStart = ref.watch(weekStartProvider(selectedDate));
    
    return statsAsync.when(
      data: (stats) {
        return Container(
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
          decoration: BoxDecoration(
             color: CupertinoDynamicColor.resolve(CupertinoColors.systemGroupedBackground, context),
             // border?
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: List.generate(7, (index) {
              final dayIndex = index + 1; // 1=Mon
              final date = weekStart.add(Duration(days: index));
              final isSelected = date.year == selectedDate.year && 
                                 date.month == selectedDate.month && 
                                 date.day == selectedDate.day;
              final isToday = _isToday(date);
              
              final duration = stats[dayIndex] ?? Duration.zero;
              final hours = duration.inMinutes / 60.0;
              
              // Calculate intensity: 0..1 (max 8 hours)
              final intensity = (hours / 8.0).clamp(0.0, 1.0);
              
              return GestureDetector(
                onTap: () {
                  ref.read(selectedDateProvider.notifier).state = date;
                },
                child: Column(
                  children: [
                    Text(
                      DateFormat.E().format(date)[0], // M, T, W...
                      style: TextStyle(
                        fontSize: 12,
                        color: isSelected 
                            ? CupertinoColors.activeBlue 
                            : CupertinoColors.secondaryLabel.resolveFrom(context),
                        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Container(
                      width: 32,
                      height: 32,
                      decoration: BoxDecoration(
                        color: isSelected && intensity == 0 
                            ? CupertinoColors.activeBlue.withOpacity(0.2) // Selected empty
                            : CupertinoColors.activeBlue.withOpacity(
                                intensity == 0 ? 0.05 : 0.2 + (intensity * 0.8)
                              ),
                        borderRadius: BorderRadius.circular(8),
                        border: isToday 
                            ? Border.all(color: CupertinoColors.activeBlue, width: 2) 
                            : null,
                      ),
                      alignment: Alignment.center,
                      child: intensity > 0 
                          ? Text(
                              duration.inHours > 0 ? '${duration.inHours}' : '',
                              style: const TextStyle(
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                                color: CupertinoColors.black, // Depending on opacity...
                              ),
                            )
                          : null,
                    ),
                  ],
                ),
              );
            }),
          ),
        );
      },
      loading: () => const SizedBox(height: 60, child: Center(child: CupertinoActivityIndicator())),
      error: (_, __) => const SizedBox.shrink(),
    );
  }
  
  bool _isToday(DateTime date) {
    final now = DateTime.now();
    return date.year == now.year && date.month == now.month && date.day == now.day;
  }
}

extension CupertinoColorsResolver on CupertinoColors {
   static Color customColor(BuildContext context, {required Color color}) {
     return CupertinoDynamicColor.resolve(color, context);
   }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/providers/calendar_view_state.dart calendar_view_state.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider для хранения выбранной даты в календаре
final selectedDateProvider = StateProvider<DateTime>((ref) {
  return DateTime.now();
});


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/providers/weekly_stats_provider.dart weekly_stats_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/repository_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;

/// Начало недели (Понедельник) для выбранной даты
final weekStartProvider = Provider.family<DateTime, DateTime>((ref, date) {
  final d = DateTime(date.year, date.month, date.day);
  return d.subtract(Duration(days: d.weekday - 1));
});

/// Статистика активности по дням недели (Duration per day)
final weeklyActivityStatsProvider = StreamProvider.family<Map<int, Duration>, DateTime>((ref, selectedDate) {
  final startOfWeek = ref.watch(weekStartProvider(selectedDate));
  final endOfWeek = startOfWeek.add(const Duration(days: 7));
  
  final repo = ref.watch(sessionRepositoryProvider);
  
  return repo.watchSessionsForPeriod(from: startOfWeek, to: endOfWeek).map((items) {
    final stats = <int, Duration>{};
    for (int i = 1; i <= 7; i++) {
      stats[i] = Duration.zero;
    }
    
    for (final item in items) {
      final session = item.session;
      final date = session.startAt;
      // Если сессия пересекает дни - это сложно. Для MVP считаем по startAt.
      // Или лучше? startAt для day counting.
      // Простая логика: весь duration приписываем дню старта.
      // TODO: Split duration across midnight if needed.
      
      final dayOfWeek = date.weekday;
      
      final duration = session.endAt?.difference(session.startAt) ?? Duration.zero; // Active sessions excluded or calc till now?
      // Если активная - считаем до сейчас?
      // Для heatmap лучше считать завершенные или до текущего момента.
      // Пусть пока завершенные.
      
      stats[dayOfWeek] = (stats[dayOfWeek] ?? Duration.zero) + duration;
    }
    return stats;
  });
});


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/features/calendar/providers/session_list_provider.dart session_list_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tempo/src/core/di/parts/repository_providers.dart';
import 'package:tempo/src/data/database/drift_database.dart' hide ActivityType;

/// Provider для получения списка сессий за конкретный день
final sessionsForDayProvider = StreamProvider.family<List<Session>, DateTime>((ref, date) {
  final repository = ref.watch(sessionRepositoryProvider);
  
  // Начало дня
  final from = DateTime(date.year, date.month, date.day);
  // Конец дня (начало следующего)
  final to = from.add(const Duration(days: 1));
  
  return repository
      .watchSessionsForPeriod(from: from, to: to)
      .map((list) => list.map((e) => e.session).toList());
});


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/theme.dart theme.dart
// ignore_for_file: strict_top_level_inference

import 'package:flutter/material.dart';

import 'src/theme_data.dart';

export 'src/theme_data.dart';

/// Extension on [BuildContext] to provide convenient access to theme-related
/// properties and utilities.
extension BuildContextExtension on BuildContext {
  /// Internal getter to access the current theme data.
  ThemeData get _theme => Theme.of(this);

  /// Gets the light theme data configuration.
  ThemeData get lightTheme => $LightThemeData()();

  /// Gets the dark theme data configuration.
  ThemeData get darkTheme => $DarkThemeData()();
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/tempo_colors.dart tempo_colors.dart
import 'package:flutter/material.dart';

class TempoColors {
  static const dueToday = Color(0xFFFF5757);
  static const dueTomorrow = Color(0xFFFFB84D);
  static const repeating = Color(0xFFB794F6);
  static const emptyTimeSlot = Color(0xFFF5F5F5);
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/theme_provider.dart theme_provider.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Simple boolean provider: true = dark, false = light
// Or Enum if we want system preference support
enum AppThemeMode { light, dark }

class ThemeNotifier extends Notifier<AppThemeMode> {
  @override
  AppThemeMode build() {
    // Default to light or check platform brightness initially?
    // Let's default to light for now as per design
    return AppThemeMode.light;
  }

  void toggle() {
    state = state == AppThemeMode.light ? AppThemeMode.dark : AppThemeMode.light;
  }

  void setMode(AppThemeMode mode) {
    state = mode;
  }
}

final themeProvider = NotifierProvider<ThemeNotifier, AppThemeMode>(ThemeNotifier.new);


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_data.dart theme_data.dart
import 'package:flutter/material.dart';

class $LightThemeData {
  ThemeData call() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
    );
  }
}

class $DarkThemeData {
  ThemeData call() {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: ColorScheme.fromSeed(
        seedColor: Colors.blue, 
        brightness: Brightness.dark,
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/dimensions.dart dimensions.dart
import 'package:flutter/material.dart';

class Dimensions extends ThemeExtension<Dimensions> {
  const Dimensions();

  final spacing = const _Spacing();
  final padding = const _Padding();
  final margin = const _Margin();
  final radius = const _Radius();

  /// Source of truth
  static const double _v1 = 1;
  static const double _v1_25 = 1.25;
  static const double _v2 = 2;
  static const double _v4 = 4;
  static const double _v6 = 6;
  static const double _v8 = 8;
  static const double _v12 = 12;
  static const double _v16 = 16;
  static const double _v20 = 20;
  static const double _v24 = 24;
  static const double _v30 = 30;
  static const double _v32 = 32;
  static const double _v44 = 44;
  static const double _v48 = 48;
  static const double _v66 = 66;
  static const double _v80 = 80;
  static const double _v100 = 100;
  static const double _v200 = 200;
  static const double _v210 = 210;

  @override
  ThemeExtension<Dimensions> lerp(
    covariant ThemeExtension<Dimensions>? other,
    double t,
  ) {
    if (other is! Dimensions) {
      return this;
    }
    // Constants don't really lerp, but we return 'this' (or other if t >= 0.5)
    // as per previous behavior. If we wanted to lerp, we'd need to lerp the
    // fields, but these are just buckets of constants.
    return t < 0.5 ? this : other;
  }

  @override
  ThemeExtension<Dimensions> copyWith() {
    return const Dimensions();
  }
}

class _Spacing {
  const _Spacing();

  final double s1 = Dimensions._v1;
  final double s1_25 = Dimensions._v1_25;
  final double s2 = Dimensions._v2;
  final double s4 = Dimensions._v4;
  final double s6 = Dimensions._v6;
  final double s8 = Dimensions._v8;
  final double s12 = Dimensions._v12;
  final double s16 = Dimensions._v16;
  final double s24 = Dimensions._v24;
  final double s30 = Dimensions._v30;
  final double s32 = Dimensions._v32;
  final double s44 = Dimensions._v44;
  final double s48 = Dimensions._v48;
  final double s66 = Dimensions._v66;
  final double s80 = Dimensions._v80;
  final double s100 = Dimensions._v100;
  final double s200 = Dimensions._v200;
  final double s210 = Dimensions._v210;
}

class _Padding {
  const _Padding();

  final double p4 = Dimensions._v4;
  final double p16 = Dimensions._v16;
  final double p20 = Dimensions._v20;
  final double p24 = Dimensions._v24;
}

class _Margin {
  const _Margin();

  final double m6 = Dimensions._v6;
}

class _Radius {
  const _Radius();

  final double r4 = Dimensions._v4;
  final double r6 = Dimensions._v6;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/colors.dart colors.dart
import 'package:flutter/material.dart';

part 'color_extension.dart';
part 'part/app_bar_colors.dart';
part 'part/bottom_nav_bar_colors.dart';
part 'part/page_view_colors.dart';
part 'part/text_colors.dart';
part 'primitive.dart';


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/color_extension.dart color_extension.dart
part of 'colors.dart';

class ColorExtension {
  const ColorExtension({
    required this.border,
    required this.icon,
    required this.onPrimary,
    required this.primary,
    required this.scaffoldBackground,
    required this.success,
    required this.error,
    required this.warning,
    required this.info,
    required this.disabled,
    required this.active,
    required this.inactive,
    required this.appBar,
    required this.bottomNavBar,
    required this.pageView,
    required this.text,
  });

  final Color border;
  final Color icon;
  final Color onPrimary;
  final Color primary;
  final Color scaffoldBackground;
  final Color success;
  final Color error;
  final Color warning;
  final Color info;
  final Color disabled;
  final Color active;
  final Color inactive;

  final AppBarColors appBar;
  final BottomNavBarColors bottomNavBar;
  final PageViewColors pageView;
  final TextColors text;
}

class LightColorExtension extends ThemeExtension<LightColorExtension>
    implements ColorExtension {
  const LightColorExtension({
    this.border = _Primitive.neutral20,
    this.icon = _Primitive.neutral40,
    this.onPrimary = _Primitive.neutral0,
    this.primary = _Primitive.brand,
    this.scaffoldBackground = _Primitive.neutral0,
    this.success = _Primitive.success,
    this.error = _Primitive.error,
    this.warning = _Primitive.warning,
    this.info = _Primitive.info,
    this.disabled = _Primitive.neutral20,
    this.active = _Primitive.brand,
    this.inactive = _Primitive.neutral30,
    this.appBar = const _LightAppBarColors(),
    this.bottomNavBar = const _LightBottomNavBarColors(),
    this.pageView = const _LightPageViewColors(),
    this.text = const _LightTextColors(),
  });

  @override
  final Color border;

  @override
  final Color icon;

  @override
  final Color onPrimary;

  @override
  final Color primary;

  @override
  final Color scaffoldBackground;

  @override
  final AppBarColors appBar;

  @override
  final BottomNavBarColors bottomNavBar;

  @override
  final PageViewColors pageView;

  @override
  final TextColors text;

  @override
  final Color success;

  @override
  final Color error;

  @override
  final Color warning;

  @override
  final Color info;

  @override
  final Color disabled;

  @override
  final Color active;

  @override
  final Color inactive;

  @override
  LightColorExtension copyWith({
    Color? border,
    Color? icon,
    Color? onPrimary,
    Color? primary,
    Color? scaffoldBackground,
    Color? success,
    Color? error,
    Color? warning,
    Color? info,
    Color? disabled,
    Color? active,
    Color? inactive,
    AppBarColors? appBar,
    BottomNavBarColors? bottomNavBar,
    PageViewColors? pageView,
    TextColors? text,
  }) {
    return LightColorExtension(
      border: border ?? this.border,
      icon: icon ?? this.icon,
      onPrimary: onPrimary ?? this.onPrimary,
      primary: primary ?? this.primary,
      scaffoldBackground: scaffoldBackground ?? this.scaffoldBackground,
      success: success ?? this.success,
      error: error ?? this.error,
      warning: warning ?? this.warning,
      info: info ?? this.info,
      disabled: disabled ?? this.disabled,
      active: active ?? this.active,
      inactive: inactive ?? this.inactive,
      appBar: appBar ?? this.appBar,
      bottomNavBar: bottomNavBar ?? this.bottomNavBar,
      pageView: pageView ?? this.pageView,
      text: text ?? this.text,
    );
  }

  @override
  ThemeExtension<LightColorExtension> lerp(
    covariant ThemeExtension<LightColorExtension>? other,
    double t,
  ) {
    if (other is! LightColorExtension) {
      return this;
    }

    return LightColorExtension(
      border: Color.lerp(border, other.border, t)!,
      icon: Color.lerp(icon, other.icon, t)!,
      onPrimary: Color.lerp(onPrimary, other.onPrimary, t)!,
      primary: Color.lerp(primary, other.primary, t)!,
      scaffoldBackground: Color.lerp(
        scaffoldBackground,
        other.scaffoldBackground,
        t,
      )!,
      success: Color.lerp(success, other.success, t)!,
      error: Color.lerp(error, other.error, t)!,
      warning: Color.lerp(warning, other.warning, t)!,
      info: Color.lerp(info, other.info, t)!,
      disabled: Color.lerp(disabled, other.disabled, t)!,
      active: Color.lerp(active, other.active, t)!,
      inactive: Color.lerp(inactive, other.inactive, t)!,
      // Complex objects are harder to lerp, so we'll just use whichever is
      // appropriate based on animation progress
      appBar: t < 0.5 ? appBar : other.appBar,
      bottomNavBar: t < 0.5 ? bottomNavBar : other.bottomNavBar,
      pageView: t < 0.5 ? pageView : other.pageView,
      text: t < 0.5 ? text : other.text,
    );
  }
}

class DarkColorExtension extends ThemeExtension<DarkColorExtension>
    implements ColorExtension {
  const DarkColorExtension({
    this.border = _Primitive.neutral30,
    this.icon = _Primitive.neutral0,
    this.onPrimary = _Primitive.neutral90,
    this.primary = _Primitive.brand,
    this.scaffoldBackground = _Primitive.neutral60,
    this.success = _Primitive.success,
    this.error = _Primitive.error,
    this.warning = _Primitive.warning,
    this.info = _Primitive.info,
    this.disabled = _Primitive.neutral20,
    this.active = _Primitive.brand,
    this.inactive = _Primitive.neutral30,
    this.appBar = const _DarkAppBarColors(),
    this.bottomNavBar = const _DarkBottomNavBarColors(),
    this.pageView = const _DarkPageViewColors(),
    this.text = const _DarkTextColors(),
  });

  @override
  final Color border;

  @override
  final Color icon;

  @override
  final Color onPrimary;

  @override
  final Color primary;

  @override
  final Color scaffoldBackground;

  @override
  final AppBarColors appBar;

  @override
  final BottomNavBarColors bottomNavBar;

  @override
  final PageViewColors pageView;

  @override
  final TextColors text;

  @override
  final Color success;

  @override
  final Color error;

  @override
  final Color warning;

  @override
  final Color info;

  @override
  final Color disabled;

  @override
  final Color active;

  @override
  final Color inactive;

  @override
  DarkColorExtension copyWith({
    Color? border,
    Color? icon,
    Color? onPrimary,
    Color? primary,
    Color? scaffoldBackground,
    Color? success,
    Color? error,
    Color? warning,
    Color? info,
    Color? disabled,
    Color? active,
    Color? inactive,
    AppBarColors? appBar,
    BottomNavBarColors? bottomNavBar,
    PageViewColors? pageView,
    TextColors? text,
  }) {
    return DarkColorExtension(
      border: border ?? this.border,
      icon: icon ?? this.icon,
      onPrimary: onPrimary ?? this.onPrimary,
      primary: primary ?? this.primary,
      scaffoldBackground: scaffoldBackground ?? this.scaffoldBackground,
      success: success ?? this.success,
      error: error ?? this.error,
      warning: warning ?? this.warning,
      info: info ?? this.info,
      disabled: disabled ?? this.disabled,
      active: active ?? this.active,
      inactive: inactive ?? this.inactive,
      appBar: appBar ?? this.appBar,
      bottomNavBar: bottomNavBar ?? this.bottomNavBar,
      pageView: pageView ?? this.pageView,
      text: text ?? this.text,
    );
  }

  @override
  ThemeExtension<DarkColorExtension> lerp(
    covariant ThemeExtension<DarkColorExtension>? other,
    double t,
  ) {
    if (other is! DarkColorExtension) {
      return this;
    }

    return DarkColorExtension(
      border: Color.lerp(border, other.border, t)!,
      icon: Color.lerp(icon, other.icon, t)!,
      onPrimary: Color.lerp(onPrimary, other.onPrimary, t)!,
      primary: Color.lerp(primary, other.primary, t)!,
      scaffoldBackground: Color.lerp(
        scaffoldBackground,
        other.scaffoldBackground,
        t,
      )!,
      success: Color.lerp(success, other.success, t)!,
      error: Color.lerp(error, other.error, t)!,
      warning: Color.lerp(warning, other.warning, t)!,
      info: Color.lerp(info, other.info, t)!,
      disabled: Color.lerp(disabled, other.disabled, t)!,
      active: Color.lerp(active, other.active, t)!,
      // Complex objects are harder to lerp, so we'll just use whichever is
      // appropriate based on animation progress
      appBar: t < 0.5 ? appBar : other.appBar,
      bottomNavBar: t < 0.5 ? bottomNavBar : other.bottomNavBar,
      pageView: t < 0.5 ? pageView : other.pageView,
      text: t < 0.5 ? text : other.text,
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/primitive.dart primitive.dart
part of 'colors.dart';

/// Primitive color palette
class _Primitive {
  static const Color brand = Color(0xFF1877F2);

  // Neutral colors
  static const Color neutral0 = Color(0xFFFFFFFF);
  static const Color neutral10 = Color(0xFFF2F8FF);
  static const Color neutral20 = Color(0xFFBABABD);
  static const Color neutral30 = Color(0xFFD5DCE4);
  static const Color neutral40 = Color(0xFF75757C);
  static const Color neutral50 = Color(0xFF313137);
  static const Color neutral60 = Color(0xFF1B1B1B);
  static const Color neutral90 = Color(0xFF000000);

  // Semantic colors
  static const Color success = Color(0xFF008000);
  static const Color error = Color(0xFFFF0000);
  static const Color warning = Color(0xFFFFFF00);
  static const Color info = brand;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/part/bottom_nav_bar_colors.dart bottom_nav_bar_colors.dart
part of '../colors.dart';

abstract class BottomNavBarColors {
  const BottomNavBarColors();

  Color get selectedItem;
  Color get unselectedItem;
}

class _LightBottomNavBarColors extends BottomNavBarColors {
  const _LightBottomNavBarColors();

  @override
  Color get selectedItem => _Primitive.brand;

  @override
  Color get unselectedItem => _Primitive.neutral20;
}

class _DarkBottomNavBarColors extends BottomNavBarColors {
  const _DarkBottomNavBarColors();

  @override
  Color get selectedItem => _Primitive.brand;

  @override
  Color get unselectedItem => _Primitive.neutral20;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/part/page_view_colors.dart page_view_colors.dart
part of '../colors.dart';

abstract class PageViewColors {
  const PageViewColors();

  Color get active;
  Color get inactive;
}

class _LightPageViewColors extends PageViewColors {
  const _LightPageViewColors();

  @override
  Color get active => _Primitive.brand;

  @override
  Color get inactive => _Primitive.neutral20;
}

class _DarkPageViewColors extends PageViewColors {
  const _DarkPageViewColors();

  @override
  Color get active => _Primitive.brand;

  @override
  Color get inactive => _Primitive.neutral20;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/part/app_bar_colors.dart app_bar_colors.dart
part of '../colors.dart';

abstract class AppBarColors {
  const AppBarColors();

  Color get background;
  Color get icon;
  Color get surfaceTint;
  Color get title;
}

class _LightAppBarColors extends AppBarColors {
  const _LightAppBarColors();

  @override
  Color get background => _Primitive.neutral10;

  @override
  Color get icon => _Primitive.neutral60;

  @override
  Color get surfaceTint => _Primitive.neutral10;

  @override
  Color get title => _Primitive.neutral50;
}

class _DarkAppBarColors extends AppBarColors {
  const _DarkAppBarColors();

  @override
  Color get background => _Primitive.neutral60;

  @override
  Color get icon => _Primitive.neutral0;

  @override
  Color get surfaceTint => _Primitive.neutral60;

  @override
  Color get title => _Primitive.neutral0;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/theme_extensions/src/colors/part/text_colors.dart text_colors.dart
part of '../colors.dart';

abstract class TextColors {
  const TextColors();

  Color get primary;
  Color get secondary;
  Color get tertiary;
}

class _LightTextColors extends TextColors {
  const _LightTextColors();

  @override
  Color get primary => _Primitive.neutral50;

  @override
  Color get secondary => _Primitive.neutral40;

  @override
  Color get tertiary => _Primitive.neutral20;
}

class _DarkTextColors extends TextColors {
  const _DarkTextColors();

  @override
  Color get primary => _Primitive.neutral0;

  @override
  Color get secondary => _Primitive.neutral20;

  @override
  Color get tertiary => _Primitive.neutral20;
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/part/button_theme_data.dart button_theme_data.dart
part of '../theme_data.dart';

/// Filled Button
///
/// Light Theme
class _FilledButtonLightThemeData with ThemeExtensions {
  FilledButtonThemeData call() {
    return FilledButtonThemeData(
      style: ButtonStyle(
        shape: WidgetStateProperty.all(
          StadiumBorder(
            side: BorderSide(
              color: lightColor.primary,
              width: dimensions.spacing.s2,
            ),
          ),
        ),
        padding: WidgetStateProperty.all(
          EdgeInsets.symmetric(horizontal: dimensions.spacing.s24),
        ),
        minimumSize: WidgetStateProperty.all(
          Size(double.infinity, dimensions.spacing.s48),
        ),
        textStyle: WidgetStateProperty.all(
          const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }
}

/// Dark Theme
class _FilledButtonDarkThemeData with ThemeExtensions {
  FilledButtonThemeData call() {
    return FilledButtonThemeData(
      style: ButtonStyle(
        shape: WidgetStateProperty.all(
          StadiumBorder(
            side: BorderSide(
              color: darkColor.primary,
              width: dimensions.spacing.s2,
            ),
          ),
        ),
        padding: WidgetStateProperty.all(
          EdgeInsets.symmetric(horizontal: dimensions.spacing.s24),
        ),
        minimumSize: WidgetStateProperty.all(
          Size(double.infinity, dimensions.spacing.s48),
        ),
        textStyle: WidgetStateProperty.all(
          const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }
}

/// Elevated Button
///
/// Light Theme
class _ElevatedButtonLightThemeData with ThemeExtensions {
  ElevatedButtonThemeData call() {
    return ElevatedButtonThemeData(
      style: ButtonStyle(
        elevation: WidgetStateProperty.all(0),
        shape: WidgetStateProperty.all(
          StadiumBorder(
            side: BorderSide(
              color: lightColor.primary,
              width: dimensions.spacing.s2,
            ),
          ),
        ),
        padding: WidgetStateProperty.all(
          EdgeInsets.symmetric(horizontal: dimensions.spacing.s24),
        ),
        minimumSize: WidgetStateProperty.all(
          Size(double.infinity, dimensions.spacing.s48),
        ),
        textStyle: WidgetStateProperty.all(
          const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }
}

/// Dark Theme
class _ElevatedButtonDarkThemeData with ThemeExtensions {
  ElevatedButtonThemeData call() {
    return ElevatedButtonThemeData(
      style: ButtonStyle(
        elevation: WidgetStateProperty.all(0),
        shape: WidgetStateProperty.all(
          StadiumBorder(
            side: BorderSide(
              color: darkColor.primary,
              width: dimensions.spacing.s2,
            ),
          ),
        ),
        padding: WidgetStateProperty.all(
          EdgeInsets.symmetric(horizontal: dimensions.spacing.s24),
        ),
        minimumSize: WidgetStateProperty.all(
          Size(double.infinity, dimensions.spacing.s48),
        ),
        textStyle: WidgetStateProperty.all(
          const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }
}

/// Text Button
///
/// Light Theme
class _TextButtonLightThemeData with ThemeExtensions {
  TextButtonThemeData call() {
    return TextButtonThemeData(
      style: ButtonStyle(
        foregroundColor: WidgetStatePropertyAll(lightColor.text.secondary),
        textStyle: WidgetStateProperty.all(
          const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
        ),
      ),
    );
  }
}

/// Dark Theme
class _TextButtonDarkThemeData with ThemeExtensions {
  TextButtonThemeData call() {
    return TextButtonThemeData(
      style: ButtonStyle(
        foregroundColor: WidgetStatePropertyAll(darkColor.text.secondary),
        textStyle: WidgetStateProperty.all(
          const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/part/bottom_navigation_bar_theme_data.dart bottom_navigation_bar_theme_data.dart
part of '../theme_data.dart';

class _BottomNavigationBarLightThemeData with ThemeExtensions {
  BottomNavigationBarThemeData call() {
    return BottomNavigationBarThemeData(
      elevation: .5,
      showSelectedLabels: true,
      showUnselectedLabels: true,
      type: BottomNavigationBarType.fixed,
      selectedItemColor: lightColor.bottomNavBar.selectedItem,
      unselectedItemColor: lightColor.bottomNavBar.unselectedItem,
      selectedLabelStyle: const TextStyle(
        fontSize: 12,
        fontWeight: FontWeight.w500,
      ),
      unselectedLabelStyle: const TextStyle(fontSize: 12),
    );
  }
}

class _BottomNavigationBarDarkThemeData with ThemeExtensions {
  BottomNavigationBarThemeData call() {
    return BottomNavigationBarThemeData(
      elevation: .5,
      showSelectedLabels: true,
      showUnselectedLabels: true,
      type: BottomNavigationBarType.fixed,
      selectedItemColor: darkColor.bottomNavBar.selectedItem,
      unselectedItemColor: darkColor.bottomNavBar.unselectedItem,
      selectedLabelStyle: const TextStyle(
        fontSize: 12,
        fontWeight: FontWeight.w500,
      ),
      unselectedLabelStyle: const TextStyle(fontSize: 12),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/part/checkbox_theme.dart checkbox_theme.dart
part of '../theme_data.dart';

class _CheckboxTheme with ThemeExtensions {
  CheckboxThemeData call() {
    return CheckboxThemeData(
      side: BorderSide(
        width: dimensions.spacing.s1_25,
        color: lightColor.border,
      ),
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(dimensions.radius.r4),
      ),
      fillColor: WidgetStateProperty.resolveWith((states) {
        if (states.contains(WidgetState.selected)) {
          return lightColor.primary;
        }
        return lightColor.scaffoldBackground;
      }),
      checkColor: WidgetStateProperty.resolveWith((states) {
        if (states.contains(WidgetState.selected)) {
          return lightColor.onPrimary;
        }
        return lightColor.border;
      }),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/part/app_bar_theme.dart app_bar_theme.dart
part of '../theme_data.dart';

class _AppBarLightTheme with ThemeExtensions {
  AppBarTheme call() {
    return AppBarTheme(
      elevation: 1,
      titleSpacing: 0,
      centerTitle: false,
      backgroundColor: lightColor.appBar.background,
      surfaceTintColor: lightColor.appBar.surfaceTint,
      titleTextStyle: textStyle.headingSmall.copyWith(
        color: lightColor.text.primary,
      ),
      iconTheme: IconThemeData(color: lightColor.appBar.icon),
    );
  }
}

class _AppBarDarkTheme with ThemeExtensions {
  AppBarTheme call() {
    return AppBarTheme(
      elevation: 1,
      titleSpacing: 0,
      centerTitle: false,
      backgroundColor: darkColor.appBar.background,
      surfaceTintColor: darkColor.appBar.surfaceTint,
      titleTextStyle: textStyle.headingSmall.copyWith(
        color: darkColor.text.primary,
      ),
      iconTheme: IconThemeData(color: darkColor.appBar.icon),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/part/dropdown_menu_theme_data.dart dropdown_menu_theme_data.dart
part of '../theme_data.dart';

class _DropdownMenuLightThemeData with ThemeExtensions {
  DropdownMenuThemeData call() {
    return DropdownMenuThemeData(
      inputDecorationTheme: _InputDecorationLightTheme()(),
    );
  }
}

class _DropdownMenuDarkThemeData with ThemeExtensions {
  DropdownMenuThemeData call() {
    return DropdownMenuThemeData(
      inputDecorationTheme: _InputDecorationDarkTheme()(),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/theme/src/part/input_decoration_theme.dart input_decoration_theme.dart
part of '../theme_data.dart';

class _InputDecorationLightTheme with ThemeExtensions {
  InputDecorationTheme call() {
    final BorderRadius borderRadius = BorderRadius.circular(
      dimensions.radius.r6,
    );

    return InputDecorationTheme(
      hintStyle: textStyle.bodyLarge.copyWith(color: lightColor.text.secondary),
      contentPadding: EdgeInsets.symmetric(
        vertical: dimensions.spacing.s12,
        horizontal: dimensions.spacing.s16,
      ),
      border: OutlineInputBorder(borderRadius: borderRadius),
      enabledBorder: OutlineInputBorder(
        borderRadius: borderRadius,
        borderSide: BorderSide(
          color: lightColor.border,
          width: dimensions.spacing.s1,
        ),
      ),
      suffixIconColor: lightColor.icon,
      disabledBorder: OutlineInputBorder(borderRadius: borderRadius),
    );
  }
}

class _InputDecorationDarkTheme with ThemeExtensions {
  InputDecorationTheme call() {
    final BorderRadius borderRadius = BorderRadius.circular(
      dimensions.radius.r6,
    );

    return InputDecorationTheme(
      hintStyle: textStyle.bodyLarge.copyWith(color: darkColor.text.secondary),
      contentPadding: EdgeInsets.symmetric(
        vertical: dimensions.spacing.s12,
        horizontal: dimensions.spacing.s16,
      ),
      border: OutlineInputBorder(borderRadius: borderRadius),
      enabledBorder: OutlineInputBorder(
        borderRadius: borderRadius,
        borderSide: BorderSide(
          color: darkColor.border,
          width: dimensions.spacing.s1,
        ),
      ),
      suffixIconColor: darkColor.icon,
      disabledBorder: OutlineInputBorder(borderRadius: borderRadius),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/widgets/navigation_shell.dart navigation_shell.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/extensions/app_localization.dart';
import '../theme/theme.dart';
import 'text/typography.dart';

class NavigationShell extends StatefulWidget {
  const NavigationShell({super.key, required this.statefulNavigationShell});

  final StatefulNavigationShell statefulNavigationShell;

  @override
  State<NavigationShell> createState() => _NavigationShellState();
}

class _NavigationShellState extends State<NavigationShell> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const HeadingSmallText('Flutter Template'),
        titleSpacing: context.spacing.s16,
      ),
      body: widget.statefulNavigationShell,
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: widget.statefulNavigationShell.currentIndex,
        onTap: (index) {
          widget.statefulNavigationShell.goBranch(index);
        },
        items: [
          BottomNavigationBarItem(
            icon: const Icon(Icons.home),
            label: context.locale.home,
          ),
          BottomNavigationBarItem(
            icon: const Icon(Icons.person),
            label: context.locale.profile,
          ),
        ],
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/widgets/link_text.dart link_text.dart
import 'package:flutter/material.dart';

import '../theme/theme.dart';

class LinkText extends StatelessWidget {
  const LinkText({
    super.key,
    required this.text,
    required this.linkText,
    required this.onTap,
  });

  final VoidCallback? onTap;
  final String text;
  final String linkText;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.center,
      child: TextButton(
        onPressed: onTap,
        child: Text.rich(
          TextSpan(
            text: text,
            style: context.textStyle.labelMedium.copyWith(
              color: context.color.text.secondary,
            ),
            children: [
              TextSpan(
                text: linkText,
                style: context.textStyle.labelMedium.copyWith(
                  color: context.color.text.primary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/widgets/main_layout.dart main_layout.dart
import 'package:flutter/material.dart';
import 'package:tempo/src/presentation/features/calendar/pages/calendar_page.dart';
import 'package:tempo/src/presentation/features/home/pages/home_page.dart';
import 'package:tempo/src/presentation/features/tasks/pages/tasks_page.dart';

class MainLayout extends StatefulWidget {
  const MainLayout({super.key});

  @override
  State<MainLayout> createState() => _MainLayoutState();
}

class _MainLayoutState extends State<MainLayout> {
  int _currentIndex = 0;

  final List<Widget> _pages = const [
    HomePage(),
    TasksPage(),
    CalendarPage(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _pages[_currentIndex],
      bottomNavigationBar: NavigationBar(
        selectedIndex: _currentIndex,
        onDestinationSelected: (index) {
          setState(() {
            _currentIndex = index;
          });
        },
        destinations: const [
          NavigationDestination(
            icon: Icon(Icons.timer_outlined),
            selectedIcon: Icon(Icons.timer),
            label: 'Track',
          ),
          NavigationDestination(
            icon: Icon(Icons.check_circle_outline),
            selectedIcon: Icon(Icons.check_circle),
            label: 'Tasks',
          ),
          NavigationDestination(
            icon: Icon(Icons.calendar_month_outlined),
            selectedIcon: Icon(Icons.calendar_month),
            label: 'Calendar',
          ),
        ],
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/widgets/ios_main_layout.dart ios_main_layout.dart
import 'package:cupertino_native/cupertino_native.dart';
import 'package:flutter/cupertino.dart';
import 'package:tempo/src/presentation/features/calendar/pages/calendar_page.dart';
import 'package:tempo/src/presentation/features/home/pages/home_page.dart';
import 'package:tempo/src/presentation/features/tasks/pages/tasks_page.dart';

class IosMainLayout extends StatefulWidget {
  const IosMainLayout({super.key});

  @override
  State<IosMainLayout> createState() => _IosMainLayoutState();
}

class _IosMainLayoutState extends State<IosMainLayout> {
  int _tabIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        IndexedStack(
          index: _tabIndex,
          children: const [
            HomePage(),
            TasksPage(),
            CalendarPage(),
             // Optional Settings page placeholder if user wanted 4 items?
             // User example had 3. We have 3 features.
          ],
        ),
        Align(
          alignment: Alignment.bottomCenter,
          child: CNTabBar(
            items: const [
              CNTabBarItem(label: 'Track', icon: CNSymbol('clock.fill')),
              CNTabBarItem(label: 'Tasks', icon: CNSymbol('checklist')),
              CNTabBarItem(label: 'Calendar', icon: CNSymbol('calendar')),
            ],
            currentIndex: _tabIndex,
            onTap: (i) => setState(() => _tabIndex = i),
          ),
        ),
      ],
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/widgets/tempo_design_system.dart tempo_design_system.dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart' show Colors, Icons, BoxShadow; 

class TempoDesign {
  static const Color background = Color(0xFFF2F4F7);
  static const Color textPrimary = Color(0xFF1D1D1F);
  static const Color textSecondary = Color(0xFF86868B);
  
  static const LinearGradient glassGradient = LinearGradient(
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
    colors: [
      Color(0xFFFFFFFF),
      Color(0xFFFAFAFA), 
    ],
  );
  
  static const List<BoxShadow> softShadow = [
    BoxShadow(
      color: Color.fromRGBO(0, 0, 0, 0.05),
      offset: Offset(0, 10),
      blurRadius: 20,
    ),
    BoxShadow(
      color: Color.fromRGBO(255, 255, 255, 0.8),
      offset: Offset(-5, -5),
      blurRadius: 10,
    ),
  ];
}

class TempoCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;
  final double width;
  
  const TempoCard({
    super.key, 
    required this.child, 
    this.padding = const EdgeInsets.all(20),
    this.width = double.infinity,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: width,
      padding: padding,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(30),
        gradient: TempoDesign.glassGradient,
        boxShadow: TempoDesign.softShadow,
      ),
      child: child,
    );
  }
}

class TempoButton extends StatefulWidget {
  final Widget child;
  final VoidCallback? onPressed;
  final bool isLarge;

  const TempoButton({
    super.key, 
    required this.child, 
    this.onPressed,
    this.isLarge = false,
  });

  @override
  State<TempoButton> createState() => _TempoButtonState();
}

class _TempoButtonState extends State<TempoButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: (_) => setState(() => _isPressed = true),
      onTapUp: (_) => setState(() => _isPressed = false),
      onTapCancel: () => setState(() => _isPressed = false),
      onTap: widget.onPressed,
      child: AnimatedScale(
        scale: _isPressed ? 0.96 : 1.0,
        duration: const Duration(milliseconds: 100),
        child: Container(
          height: widget.isLarge ? 70 : 50,
          alignment: Alignment.center,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(widget.isLarge ? 25 : 16),
            gradient: const LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                Color(0xFFFFFFFF),
                Color(0xFFF0F0F3),
              ],
            ),
            boxShadow: _isPressed 
              ? [] 
              : const [
                BoxShadow(
                  color: Color.fromRGBO(0, 0, 0, 0.08),
                  offset: Offset(0, 8),
                  blurRadius: 16,
                ),
                BoxShadow(
                  color: Color.fromRGBO(255, 255, 255, 1),
                  offset: Offset(-4, -4),
                  blurRadius: 8,
                ),
              ],
          ),
          child: widget.child,
        ),
      ),
    );
  }
}

class TempoActivityChip extends StatelessWidget {
  final String label;
  final bool isSelected;
  final VoidCallback onTap;
  final Color? dotColor;

  const TempoActivityChip({
    super.key,
    required this.label,
    required this.isSelected,
    required this.onTap,
    this.dotColor,
  });

  @override
  Widget build(BuildContext context) {
     return GestureDetector(
       onTap: onTap,
       child: Container(
         margin: const EdgeInsets.symmetric(horizontal: 4),
         padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
         decoration: BoxDecoration(
           color: isSelected ? const Color(0xFFF0F0F3) : Colors.transparent, 
           borderRadius: BorderRadius.circular(20),
         ),
         child: Row(
           mainAxisSize: MainAxisSize.min,
           children: [
             if (dotColor != null) ...[
               Container(
                 width: 8,
                 height: 8,
                 decoration: BoxDecoration(
                   color: dotColor,
                   shape: BoxShape.circle,
                 ),
               ),
               const SizedBox(width: 8),
             ],
             Text(
               label,
               style: TextStyle(
                 fontSize: 15,
                 fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,
                 color: isSelected ? CupertinoColors.black : CupertinoColors.systemGrey,
               ),
             ),
           ],
         ),
       ),
     );
  }
}

class TempoBadge extends StatelessWidget {
  final String text;
  final Color color;

  const TempoBadge({
    super.key,
    required this.text,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(6),
      ),
      child: Text(
        text,
        style: TextStyle(
          color: color,
          fontSize: 12,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/widgets/loading_indicator.dart loading_indicator.dart
import 'package:flutter/material.dart';

import '../theme/theme.dart';

class LoadingIndicator extends StatelessWidget {
  const LoadingIndicator({super.key});

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: context.spacing.s30,
      height: context.spacing.s30,
      child: CircularProgressIndicator(
        valueColor: AlwaysStoppedAnimation<Color>(
          context.color.onPrimary.withValues(alpha: 0.75),
        ),
      ),
    );
  }
}


================================================================================

/home/flomik/StudioProjects/Tempo/lib/src/presentation/core/base/status.dart status.dart
enum Status { initial, loading, success, error }

extension StatusExtension on Status {
  bool get isInitial => this == Status.initial;
  bool get isLoading => this == Status.loading;
  bool get isSuccess => this == Status.success;
  bool get isError => this == Status.error;
}


================================================================================

